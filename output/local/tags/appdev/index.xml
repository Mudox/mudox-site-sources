<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Appdev on Mudox </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://localhost:1313/tags/appdev/index.xml/</link>
    <language>en-us</language>
    
    
    <updated>Tue, 28 Apr 2015 17:43:56 CST</updated>
    
    <item>
      <title>iOS NOTES - AMAP API DEPICTED</title>
      <link>http://localhost:1313/note/ios_notes_amap/</link>
      <pubDate>Tue, 28 Apr 2015 17:43:56 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_amap/</guid>
      <description>

&lt;p&gt;AMap (高德地图) APIs depicted in several graphs I draw.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;AMap Searching API&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/amap_searching_graph.svg&#34; alt=&#34;AMap Searching API Graph&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - LOCATION BASED SERVIES</title>
      <link>http://localhost:1313/note/ios_notes_lbs/</link>
      <pubDate>Fri, 17 Apr 2015 14:43:56 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_lbs/</guid>
      <description>

&lt;p&gt;Quick steps to use iOS&amp;rsquo;s LBS technology.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Core Location&lt;/h1&gt;

&lt;p&gt;iOS devices integrates various hardware components, such as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;GPS (Global Positioning System) for positioning&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hardware compass for heading monitoring.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;WiFi for positioning.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Cellular network for cell-tower triangulation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Blue tooth for iBeacon ranging.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;some data sensors for improve positioning accuracy under some circumstances.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;to provides users with following LBS abilities as much as possible:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Location Updates&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Standard location updates&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Significant location updates&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Heading monitoring&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Region monitoring&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;iBeacon ranging&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Visit events&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The &lt;code&gt;CLLocationManager&lt;/code&gt; acts just like an &lt;code&gt;NSNotificationCenter&lt;/code&gt; (but it is not
a singleton) between the LBS hardwares and your App, you use it to request the
authorization for LBS functionalities you are planning to use afterwords, and
adjusts the relevant parameters of them before starting their notification
updating loops.&lt;/p&gt;

&lt;p&gt;After you call one of its&amp;rsquo; &lt;code&gt;start***&lt;/code&gt; or &lt;code&gt;request***&lt;/code&gt; methods to emit requests
for one of the 5 LBS abilities mentioned above, the &lt;code&gt;CLLocationManager&lt;/code&gt;
activate relevant hardware components, when the data is available it notifies
you asynchronously by calling one of the its&amp;rsquo; delegate&amp;rsquo;s methods.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/core_location_map.svg&#34; alt=&#34;Core Location Map&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Work flow of using LBS abilities.&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Project setup&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Enable &lt;em&gt;Background Location Updates Background Mode&lt;/em&gt; capability.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add &lt;em&gt;NSLocationAlwaysUsageDescriptions&lt;/em&gt; or
&lt;em&gt;NSLocationWhenInUseUsageDescription&lt;/em&gt; key to info.plist.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Configuring &lt;code&gt;CLLocationManager&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Creating a &lt;code&gt;CllocationManager&lt;/code&gt; instance and hold a strong reference to it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Specify location manager&amp;rsquo;s delegate, usually be a view controller.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check &amp;amp; request authorization status.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Configures the relevant properties for the LBS functionality you are about
to use.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Before starting each LBS updating functions, there are also corresponding
APIs you can invoke to check the services availability.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Call &lt;code&gt;start**&lt;/code&gt; methods to start the various LBS notification loops.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// declare as some long-standing reference outside of function body.
let locationManager = CLLocationManager()
--------------------
// within functions ( be it in viewDidLoad() )
// designate delegate
locationManager.delegate = self
// request for authorization
locationManager.requestAlwaysAuthorization()
// configure updating related settings
locationManager.activityType = .AutomotiveNavigation
locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation
locationManager.distanceFilter = 10
// finally check device &amp;amp; service availability before starting notification loop.
if CLLocationManager.locationServicesEnabled() {
  locationManager.startUpdatingLocation()
} else {
  let alert = UIAlertController(
    title: &amp;quot;Service Not Available&amp;quot;,
    message: &amp;quot;The location is not available or has been shut down.&amp;quot;,
    preferredStyle: .Alert)
  presentViewController(alert, animated: true, completion: nil)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Implement &lt;code&gt;CLLocationManagerDelegate&lt;/code&gt; methods in you designated delegate
object to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;handle received location data updates.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;handle LBS failures.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;handle authorization status changes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;hellip;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;MapKit&lt;/h1&gt;

&lt;p&gt;In general, MapKit:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;shows map in one of three map types:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Standard&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Satellite&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hybrid&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;along with many built-in elements:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;compass&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;POIs (points of interest)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;and provides developer with two kinds of customizable presentation
facilities:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;annotations&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;overlays&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As of managing annotations, MapKit adopts the same design pattern as that is
heavily used by &lt;code&gt;UITableView&lt;/code&gt; &amp;ndash; decoupling data model from presentation tools
through &lt;strong&gt;reuse pool&lt;/strong&gt;. Hence, there comes separate class hierarchies for
storing annotation (overlay) data, and presenting them respectively.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;data object&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;all objects that conforms to &lt;code&gt;MKAnnotation&lt;/code&gt; protocol, are responsible for
storing data for annotations, such as location, textual info, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;all objects that conforms to &lt;code&gt;MKOverlay&lt;/code&gt; protocol, are responsible for
storing data for overlays, such as location, etc.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;presentation tools&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;instances that inherit from &lt;code&gt;MKAnnotationView&lt;/code&gt; can be &lt;strong&gt;reused&lt;/strong&gt; to display a data objects.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;instances that inherit from &lt;code&gt;MKOverlayRenderer&lt;/code&gt; can be used to display a overlay objects.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/map_kit_map.svg&#34; alt=&#34;MapKit map&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Customize annotation view&lt;/h2&gt;

&lt;p&gt;A annotation view usually consist of 2 parts:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The view view.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Set its&amp;rsquo; &lt;code&gt;image&lt;/code&gt; property to change its&amp;rsquo; appearance.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The callout view, which is popped up when the pin view is selected.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The built-in callout view is not exposed for customization, so we should disable the &lt;code&gt;canShowCallout&lt;/code&gt; property&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SWIFT NOTES - FUNCTIONS</title>
      <link>http://localhost:1313/note/swift_notes_functions/</link>
      <pubDate>Mon, 13 Apr 2015 16:26:59 CST</pubDate>
      
      <guid>http://localhost:1313/note/swift_notes_functions/</guid>
      <description>

&lt;p&gt;Excerpts from the &amp;ldquo;Functions&amp;rdquo; section of the official docuemnt &amp;ldquo;The Swift
Programming Language&amp;rdquo;&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Function Parameters&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Parameter names&lt;/h2&gt;

&lt;p&gt;A parameter name can have a &lt;strong&gt;internal name&lt;/strong&gt; and an &lt;strong&gt;external name&lt;/strong&gt; declared
in the form of: &lt;code&gt;external_name internal_name: type&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func join(String string: leftString, toString rightString) -&amp;gt; String {
  return leftString + rightString
}

println(join(String: &amp;quot;Hello&amp;quot;, toString: &amp;quot; World!&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use &lt;code&gt;#&lt;/code&gt; to use the same name for both names: &lt;code&gt;#name: type&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func join(#aString: leftString, #toString) -&amp;gt; String {
  return aString + toString
}

println(join(aString: &amp;quot;Hello&amp;quot;, toString: &amp;quot; World!&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use &lt;code&gt;_&lt;/code&gt; to suppress external name: &lt;code&gt;_ internal_name: type&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func join(_ aString: leftString, _ toString) -&amp;gt; String {
  return aString + toString
}

println(join(&amp;quot;Hello&amp;quot;, &amp;quot; World!&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Parameters with default value&lt;/h2&gt;

&lt;p&gt;Default parameter values of the &lt;code&gt;[external_name /_/#]internal_name: type =
default_value&lt;/code&gt; should be placed at end of the parameter list.&lt;/p&gt;

&lt;p&gt;The compiler will synthesize a external name by reusing the internal name for
parameters with default value, if their external name is not explicitly
specified in the parameter list. (You can use &lt;code&gt;_&lt;/code&gt; to suppress this behavior,
which is not recommended.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func Foo(arg1: String, arg2: Int = 30, _ arg3: Bool, #arg4: Double) {
  ...
}

Foo(&amp;quot;text&amp;quot;, arg2: 1, true, arg4: 4.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Variadic parameters&lt;/h2&gt;

&lt;p&gt;Declare variadic parameter in form &lt;code&gt;name: type...&lt;/code&gt;, which, in the function
body, is of type &lt;code&gt;[type]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Only one variadic parameter is allowed in a parameter list, and it should be
placed after all other normal parameters or parameters with default value.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Variable parameters&lt;/h2&gt;

&lt;p&gt;Prefix parameter names with keyword &lt;code&gt;var&lt;/code&gt; to make them modifiable inside the
function body.&lt;/p&gt;

&lt;p&gt;It is just another small syntactic sugar brought by Swift, the change made in
the function body will not propagate outside the function body.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;In-Out parameters&lt;/h2&gt;

&lt;p&gt;Prefix parameters names with keyword &lt;code&gt;inout&lt;/code&gt; (which implies &lt;code&gt;var&lt;/code&gt;) to make the
change to the parameter inside function body propagate outside.&lt;/p&gt;

&lt;p&gt;When specifying argument for &lt;code&gt;inout&lt;/code&gt; parameters, prepend &lt;code&gt;&amp;amp;&lt;/code&gt; to the argument
name to indicate that it could be modified during the function call.&lt;/p&gt;

&lt;p&gt;In-out parameters cannot have default values, and variadic parameters cannot be
marked as &lt;code&gt;inout&lt;/code&gt;. If you mark a parameter as &lt;code&gt;inout&lt;/code&gt;, it cannot also be marked
as var or let.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func swapTwoInts(inout a: Int, inout b: Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}

var a = 2
var b = 10
swapTwoInts(&amp;amp;a, &amp;amp;b)
println(&amp;quot;after swapping, a = \(a), b = \(b)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;Function Return Values&lt;/h1&gt;

&lt;p&gt;Functions without a defined return type return a special value of type
&lt;strong&gt;Void&lt;/strong&gt;.  This is simply an empty tuple, in effect a tuple with zero elements,
which can be written as &lt;code&gt;()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can use a tuple type (or a optional tuple) as the return type for a
function to return multiple values as part of one compound return value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// wrap multiple return values in an optional tuple.
func minMax(array: [Int]) -&amp;gt; (min: Int, max: Int)? { ... }

if let minMax = minMax([1,2,3]) {
  // use name to fetch tuple element.
  println(&amp;quot;min: \(minMax.min)\tmax: \(minMax.max)&amp;quot;)

  // use index to fetch tuple elements.
  println(&amp;quot;min: \(minMax.0)\tmax: \(minMax.1)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;Function Types&lt;/h1&gt;

&lt;p&gt;In Swift, function is first class object, so feel free to use them as other
normal objects:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;passing them as argument into functions.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;return them from functions.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;declare theme as type alias for convenience.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;even nest their in another function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;hellip;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;typealias cmp = (Int, Int) -&amp;gt; Bool

func whichCmp(functionPassedIn: ()-&amp;gt; Bool) -&amp;gt; cmp {
  func Foo(lhs: Int, rhs: Int) -&amp;gt; Bool {
    return false
  }

  func Hoo(lhs: Int, rhs: Int) -&amp;gt; Bool {
    return true
  }

  return functionPassedIn() ? Foo : Hoo
}

func aFunc() -&amp;gt; Bool {
  return false
}

whichCmp(aFunc)(1334, 234)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - CASTING</title>
      <link>http://localhost:1313/note/ios_notes_casting/</link>
      <pubDate>Sun, 12 Apr 2015 14:43:56 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_casting/</guid>
      <description>

&lt;p&gt;Collect all my gain from study &amp;amp; using Swift&amp;rsquo;s casting mechanism here.&lt;/p&gt;

&lt;p&gt;First defining a sample class hierarchy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class SuperClass {
  func say() {
    println(&amp;quot;super class&amp;quot;)
  }
}

class Subclass: SuperClass {
  override func say() {
    println(&amp;quot;subclass&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;3 Kinds of Castings&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Natural Casting&lt;/p&gt;

&lt;p&gt;Used in &lt;strong&gt;up-casting&lt;/strong&gt; (i.e. casting from a sub-class instance to a super
class instance)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var a = SubClass()
var b = a as SuperClass
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unconditional Casting (or forced casting)&lt;/p&gt;

&lt;p&gt;Used in &lt;strong&gt;down-casting&lt;/strong&gt; (i.e. the contrary of the above).&lt;/p&gt;

&lt;p&gt;When the casting failed, it would incur a panic.&lt;/p&gt;

&lt;p&gt;Use it when you are confident about the down-casting.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conditional Casting&lt;/p&gt;

&lt;p&gt;Used in &lt;strong&gt;down-casting&lt;/strong&gt;, but it always returns optionals whether succeed
or fail, that means when not
applicalbe, instead of emitting a panic, it returns nil.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Conclusion:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Natural casting is used in &lt;em&gt;always-succeed&lt;/em&gt; castings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conditional &amp;amp; Unconditional castings are used in &lt;em&gt;might-fail&lt;/em&gt; castings.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;2 Operator for Casting&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;is&lt;/code&gt; operator&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;code&gt;as&lt;/code&gt; operators - &lt;code&gt;as&lt;/code&gt;, &lt;code&gt;as?&lt;/code&gt;, &lt;code&gt;as!&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Special casting scenarios in practice&lt;/h1&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Protocol Casting&lt;/h2&gt;

&lt;p&gt;In Swift the relationship between a protocol and the classes adopting that
protocol is like the relationship between a super class and its&amp;rsquo; sub-classes.
Hence casting a protocol object, such as the &lt;code&gt;AnyObject&lt;/code&gt; to its&amp;rsquo; underlying
class is regarded as a down-casting.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit // import AppKit

let a: AnyObject = &amp;quot;String&amp;quot;
let b: a as! String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are 3 special types: &lt;code&gt;Any&lt;/code&gt;, &lt;code&gt;AnyObject&lt;/code&gt;, &lt;code&gt;AnyClass&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;By tracing the source code, you would find the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;/// The protocol to which all classes implicitly conform.
///
/// When used as a concrete type, all known `@objc` methods and
/// properties are available, as implicitly-unwrapped-optional methods
/// and properties respectively, on each instance of `AnyObject`.
@objc procotol AnyObject {}

/// The protocol to which all class types implicitly conform.
///
/// When used as a concrete type, all known `@objc` `class` methods and
/// properties are available, as implicitly-unwrapped-optional methods
/// and properties respectively, on each instance of `AnyClass`.
typealias AnyClass = AnyObject.Type

/// The protocol to which all types implicitly conform
typealias Any = protocol&amp;lt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There exists a prerequisite for the rules all above: the &lt;code&gt;Foundation&lt;/code&gt; framework
must be imported. (Usually, you import &lt;code&gt;UIKit&lt;/code&gt; or &lt;code&gt;AppKit&lt;/code&gt;, which implicitly
import &lt;code&gt;Foundation&lt;/code&gt; framework). Only then can swift compiler be able to
recognize the &lt;code&gt;@objc&lt;/code&gt; keyword, and have Objective-C type bridging ability.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Optional AnyObject Collection Casting&lt;/h2&gt;

&lt;p&gt;For a optional of Collection of AnyObject that reference objects of the same
class (or super class) T, can be [un]conditionally casted to [T] (without
being wrapped in optional anymore)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit // import Appkit

// optional array of String.
let a: [AnyObject]? = [&amp;quot;Newyork&amp;quot;, &amp;quot;London&amp;quot;, &amp;quot;Peking&amp;quot;]
let b = a as! [String] // succeed.

// optional array of mixed object that have no common super class.
let a: [AnyObject]? = [&amp;quot;Newyork&amp;quot;, 1983, 3.14, false]
let b = a as! [String] // fail: not all element are of String.

// optinal array of mixed objects that derived from the same super class.
let a: [AnyObject]? = [Subclass(), SuperClass(), SuperClass(), Subclass()]
let b = a as! [Subclass] // succeed: not all element are of String.

// implicitly unwrapped optional dictionary with String typped keys and Int typed values.
let a: [NSObject: AnyObject]! = [&amp;quot;id1&amp;quot;: 32, &amp;quot;id2&amp;quot;: 66]
if let b = a as? [String: Int] {
  println(b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code list above, the String is a structure type in Swift (no a class
type), but it can also be referenced by a &lt;code&gt;AnyObject&lt;/code&gt; instance. The rules come
from the following excerpt from &amp;ldquo;Using Swift with Cocoa and Objective-C&amp;rdquo;
official document:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An object is AnyObject compatible if it is an instance of an Objective-C or
Swift class, or if the object can be bridged to one.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There exist several swift - Objective-C type bridging depicted as follows:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/swift_objc_bridging.svg&#34; alt=&#34;Siwft - Objective-C Bridging&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Hence, back to the code listing above, the Swift type &lt;code&gt;String&lt;/code&gt; can be bridged
to NSString &lt;code&gt;Foundation&lt;/code&gt; class, then it is &lt;code&gt;AnyObject&lt;/code&gt; compatible.&lt;/p&gt;

&lt;p&gt;In practice, there exists quit a few occasions that you need to cast optional
collections to type specific Swift collections to utilize their underlying
methods or properties.&lt;/p&gt;

&lt;p&gt;For example, when you invoke the Objective-C APIs that return &lt;code&gt;NSArray&lt;/code&gt;,
&lt;code&gt;NSDictionary&lt;/code&gt;, &lt;code&gt;NSSet&lt;/code&gt;, you would get &lt;code&gt;[AnyOject]!&lt;/code&gt; &lt;code&gt;[NSObject: AnyOject]!&lt;/code&gt;,
&lt;code&gt;[NSObject]!&lt;/code&gt; respectively, you could cast [un]conditionally to a more concrete
Swift collection type before you access the individual elements within they.&lt;/p&gt;

&lt;p&gt;When you use &lt;code&gt;as!&lt;/code&gt; (the unconditional casting), you got an unwrapped collection
in one line of code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let asset: AVURLAsset = ...
for meta in asset.commonMetadata as! [AVMetadataItem] {
  switch meta.commonKey {
  case AVMetadataCommonKeyTitle:
    item.title = meta.stringValue
  case AVMetadataCommonKeyArtist:
    item.artist = meta.stringValue
  case AVMetadataCommonKeyAlbumName:
    item.albumName = meta.stringValue
  case AVMetadataCommonKeyArtwork:
    switch meta.value {
    case let data as NSData:
      item.artwork = UIImage(data: data)
    case let dict as [NSObject: AnyObject]:
      item.artwork = UIImage(data: dict[&amp;quot;data&amp;quot;] as! NSData)
    default:
      assert(false, &amp;quot;Invalid metadata value type&amp;quot;)
    }
  default:
    break
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - KEYBOARD</title>
      <link>http://localhost:1313/note/ios_notes_keyboard/</link>
      <pubDate>Wed, 08 Apr 2015 16:19:59 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_keyboard/</guid>
      <description>

&lt;p&gt;Handle iOS keyboard poppu &amp;amp; resignment gracefully.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;UIWindow provide 6 keyboard related notifications&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;UIKeyboard[Will/Did]ShowNotification&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIKeyboard[Will/Did]HideNotification&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIKeyboard[Will/Did]ChangeFrameNotification&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After playing with these notifications above, I found:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;When you want to move obscured contents or views to above the keyboard, put
the frame adjustment code in *&lt;strong&gt;Will&lt;/strong&gt;* notifications, because the handler
methods seems to be invoked within the same animation block that provides
the keyboard revealing animation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you are only interested in tracing keyboard&amp;rsquo;s frame (more specifically the
height) during keyboard&amp;rsquo;s presence, monitoring
&lt;code&gt;UIKeyboardWillShowNotification&lt;/code&gt; seems enough, no need to monitoring
&lt;code&gt;UIKboardWillChangeFrameNotification&lt;/code&gt; additionally.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The frame size stored in &lt;code&gt;UIKeyboardFrameBeginUserInfoKey&lt;/code&gt; and
&lt;code&gt;UIKeyboardFrameEndUserInfoKey&lt;/code&gt; keys will only differ after keyboard is
first shown and before it is hidden. When the keyboard is first shown or is
resigned, the &lt;code&gt;Begin&lt;/code&gt; or &lt;code&gt;End&lt;/code&gt; frame is equal.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Strategies for move contents above the keyboard:&lt;/h1&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;For contents embedded in &lt;code&gt;UISCrollView&lt;/code&gt;s&lt;/h2&gt;

&lt;p&gt;Way #1 &amp;ndash; Adjust the bottom edge inset value of the containing scroll view&amp;rsquo;s
contentsInset property and scroll active view into visible area using
&lt;code&gt;scrollRectToVisible: animated:&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;Way #2 &amp;ndash; Adjust containing scroll view&amp;rsquo;s contentSize &amp;amp; contentOffset
properties.&lt;/p&gt;

&lt;p&gt;No matter which way above you choose, remember to adjust
&lt;code&gt;scrollIndicatorInsets&lt;/code&gt;&amp;rsquo;s bottom edge inset value to make the indicator fully
un-obscured from the keyboard.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;For contents outside any &lt;code&gt;UIScrollView&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Recalculate and set its&amp;rsquo; frame.origin.y value in
&lt;code&gt;UIKeyboardWillShowNotification&lt;/code&gt; handler method, and the movement will be
animated along with the revealing of keyboard perfectly.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func handleKeyboardNotification(notify: NSNotification) {
  let value = notify.userInfo?[UIKeyboardFrameEndUserInfoKey] as NSValue
  let keyboardHeight = value.CGRectValue().height

  switch notify.name {

  case UIKeyboardWillShowNotification:
    theViewToMove.frame.origin.y = self.view.bounds.height - keyboardHeight - theViewToMoveMargin - theViewToMove.bounds.height
    theScrollViewToAdjust.contentInset.bottom = keyboardHeight
    itemsTable.scrollIndicatorInsets.bottom = keyboardHeight

  case UIKeyboardWillHideNotification:
    theViewToMove.frame.origin.y = self.view.bounds.height - theViewToMoveMargin - theViewToMove.bounds.height
    theScrollViewToAdjust.contentInset.bottom = 0.0
    itemsTable.scrollIndicatorInsets.bottom = 0.0 // the default value

  default:
    assert(false)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;References:&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/KeyboardManagement/KeyboardManagement.html#//apple_ref/doc/uid/TP40009542-CH5-SW7&#34;&gt;Moving Contents That is Located Under the Keyboard in Text Programming Guide for iOS&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIWindow_Class/&#34;&gt;UIWindow Class Reference&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>