<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Cocoa on Mudox </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://localhost:1313/tags/cocoa/index.xml/</link>
    <language>en-us</language>
    
    
    <updated>Thu, 30 Apr 2015 15:03:56 CST</updated>
    
    <item>
      <title>Swift 官博文章翻译 - 可为空性和 Objective-C</title>
      <link>http://localhost:1313/post/trans_swift_nullability_and_objective_c/</link>
      <pubDate>Thu, 30 Apr 2015 15:03:56 CST</pubDate>
      
      <guid>http://localhost:1313/post/trans_swift_nullability_and_objective_c/</guid>
      <description>

&lt;p&gt;原文链接：&lt;a href=&#34;https://developer.apple.com/swift/blog/?id=25&#34;&gt;Nullability and Objective-C&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译者：Mudox&lt;/p&gt;

&lt;p&gt;Swift 语言的一个很棒的特性就是它能透明的和 Objective-C 代码互操作，不管是系统提供 Objective-C 框架还是那些你自己写的代码都能。然而，在 Swift 中，可为空的值与不可为空的值引用之间使用明显区别的。比如说 &lt;code&gt;NSView&lt;/code&gt; 和 &lt;code&gt;NSView?&lt;/code&gt; 在 Swift 中是两个截然不同的类型，但在 Objective-C 中他们都用 &lt;code&gt;NSView *&lt;/code&gt; 表示。由于 Swift 无法判断 &lt;code&gt;NSView *&lt;/code&gt; 到底是可为空的引用还是不可为空的引用，所以 Swift 把此类型转换为一个隐式拆箱的可为空类型（implicitly unwrapped optional）—— &lt;code&gt;NSView!&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在此前的 Xcode 版本中，Apple 公司对一些框架做了特殊处理，以让它们在 Swift 被转换为适当的可为空类型。Xcode 6.3 引入了一个新的 Objective-C 特性：可为空性注释（nullability annotation），是的程序也能对自己的代码做出同样的处理。&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;核心关键字: &lt;code&gt;__nullable&lt;/code&gt;，&lt;code&gt;__nonnull&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;这项新特性的核心就是两个关键字：&lt;code&gt;__nullable&lt;/code&gt;，&lt;code&gt;__nonnull&lt;/code&gt;。正如你所想的那样，所有 &lt;code&gt;__nullable&lt;/code&gt; 指针可以为 &lt;code&gt;NULL&lt;/code&gt; 或者 &lt;code&gt;nil&lt;/code&gt;，而所有 &lt;code&gt;__nonnull&lt;/code&gt; 指针不行。如果你违反了此规则，编译器将会发出警告。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@interface AAPLList : NSObject &amp;lt;NSCoding, NSCopying&amp;gt;
// ...
- (AAPLListItem * __nullable)itemWithName:(NSString * __nonnull)name;
@property (copy, readonly) NSArray * __nonnull allItems;
// ...
@end

// --------------

[self.list itemWithName:nil]; // warning!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在您的 Objective-C 代码中，您几乎可以在任何可以用到 &lt;code&gt;const&lt;/code&gt; 关键字的地方使用 &lt;code&gt;__nullable&lt;/code&gt;，&lt;code&gt;__nonnull&lt;/code&gt;，当然必须是修饰指针类型。Swift 还未常用的场景提供了更加漂亮的注释方式：对于那些简单的对象类型或者块类型的类成员声明，您可以使用 &lt;code&gt;__nullable&lt;/code&gt;，&lt;code&gt;__nonnull&lt;/code&gt; 非下划线版本来就注释他们。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;- (nullable AAPLListItem *)itemWithName:(nonnull NSString *)name;
- (NSInteger)indexOfItem:(nonnull AAPLListItem *)item;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于属性，您也可以使用非下划线的版本，这次不是放在属性名前面，而是把他们挪到属性列表中（括号里面）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@property (copy, nullable) NSString *name;
@property (copy, readonly, nonnull) NSArray *allItems;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;非下划线的版本看起来更加舒服，但是您任然需要把他们加到所有需要的头文件中。您可以使用监控区域（audited region）来简化这个过程，并让头文件变得更加干净。&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;监控区域（andited region)&lt;/h1&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;兼容性&lt;/h1&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;回到 Swift&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - Media Frameworks</title>
      <link>http://localhost:1313/note/ios_notes_media_frameworks/</link>
      <pubDate>Wed, 29 Apr 2015 23:43:56 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_media_frameworks/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;iOS Media Frameworks Stack&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/media_stack.svg&#34; alt=&#34;iOS media frameworks Stack&#34; /&gt;
&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;The Trunk Relation Graph&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/media_trunk_graph.svg&#34; alt=&#34;iOS media framework trunk relation graph&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift 官博文章翻译 - 通过减少动态调度来拉升程序性能</title>
      <link>http://localhost:1313/post/translation_swift_dynamic_dispath/</link>
      <pubDate>Wed, 29 Apr 2015 10:03:56 CST</pubDate>
      
      <guid>http://localhost:1313/post/translation_swift_dynamic_dispath/</guid>
      <description>

&lt;p&gt;原文链接：&lt;a href=&#34;https://developer.apple.com/swift/blog/?id=27&#34;&gt;Increasing Performance by Reducing Dynamic Dispatch &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译者：Mudox&lt;/p&gt;

&lt;p&gt;和其他很多语言一样，Swift 运行程序员改写从父类集成来的方法和属性。这意味着程序得在运行时也只用在运行时才能判断所引用的具体的方法或属性，并间接的调用或访问他们。这一技术名为“动态分配 dynamic dispatch”，通过为每次间接调用或访问增加常亮时间的开销来换取语言表达能力的提升。对于性能苛刻的代码，这类开销是不可取的。本文将展示三种通过消除此类动态性来拉升程序性能的方法：&lt;code&gt;final&lt;/code&gt;，&lt;code&gt;private&lt;/code&gt; 以及整模块优化策略。&lt;/p&gt;

&lt;p&gt;请看如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ParticleModel {
  var point = ( 0.0, 0.0 )
  var velocity = 100.0

  func updatePoint(newPoint: (Double, Double), newVelocity: Double) {
    point = newPoint
    velocity = newVelocity
  }

  func update(newP: (Double, Double), newV: Double) {
    updatePoint(newP, newVelocity: newV)
  }
}

var p = ParticleModel()
for i in stride(from: 0.0, through: 360, by: 1.0) {
  p.update((i * sin(i), i), newV:i*1000)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译器将会生成如下动态分派代码：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;调用 &lt;code&gt;update&lt;/code&gt; 于 &lt;code&gt;p&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;调用  &lt;code&gt;updatePoint&lt;/code&gt; 于 &lt;code&gt;p&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;访问 &lt;code&gt;p&lt;/code&gt; 的 &lt;code&gt;point&lt;/code&gt; 元祖属性。&lt;/li&gt;
&lt;li&gt;访问 &lt;code&gt;p&lt;/code&gt; 的 &lt;code&gt;velocity&lt;/code&gt; 属性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这也许并不是你想要的。动态调度在这里之所以必要，是因为 &lt;code&gt;ParticleModel&lt;/code&gt; 的子类可能重写其属性。&lt;/p&gt;

&lt;p&gt;在 Swift 中，动态调度通过从函数表中搜索正确的函数并间接调用他们来实现。这显然比直接调用来的慢。此外，间接调用还会阻碍很多编译器对代码的优化，这又进一步增加了程序运行的开销。在性能关键的代码中，Swift 提供了一些技术来关闭某些不必要的动态调度以拉升程序性能。&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;当你确定某个声明不会被覆盖时，使用 &lt;code&gt;final&lt;/code&gt; 关键字&lt;/h2&gt;

&lt;p&gt;关键字 &lt;code&gt;final&lt;/code&gt; 可以修饰类，方法或者属性的声明，它指示编译器这些声明不会被后续代码覆盖。这样编译器就能放心的在这些对象上关闭动态调度特性（不生成动态调度的代码）。比如下面的类属性 &lt;code&gt;point&lt;/code&gt;，&lt;code&gt;velocity&lt;/code&gt; 和函数 &lt;code&gt;updatePoint()&lt;/code&gt; 将被直接访问和调用。而方法 &lt;code&gt;update()&lt;/code&gt; 仍然需要通过动态调度来间接的被调用，它也因此能被子类们覆盖。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ParticleModel {
  final var point = ( x: 0.0, y: 0.0 )
  final var velocity = 100.0

  final func updatePoint(newPoint: (Double, Double), newVelocity: Double) {
    point = newPoint
    velocity = newVelocity
  }

  func update(newP: (Double, Double), newV: Double) {
    updatePoint(newP, newVelocity: newV)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is possible to mark an entire class as final by attaching the attribute to the class itself. This forbids subclassing the class, implying that all functions and properties of the class are final as well.&lt;/p&gt;

&lt;p&gt;您可以用 &lt;code&gt;final&lt;/code&gt; 修饰整个类的声明，这样做将直接禁止对该类的子类化，因此对其所有属性和方法的访问将都是直接的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;final class ParticleModel {
  var point = ( x: 0.0, y: 0.0 )
  var velocity = 100.0
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;为 &lt;code&gt;private&lt;/code&gt; 声明自动推导 &lt;code&gt;final&lt;/code&gt; 语义&lt;/h2&gt;

&lt;p&gt;被 &lt;code&gt;private&lt;/code&gt; 修饰的声明其可见性会限制在声明它的文件里。如果在该文件里，没有发现对该声明的覆盖，编译器就不会为该声明生成动态调度代码，而是直接的访问他们。&lt;/p&gt;

&lt;p&gt;假设在该文件中，没有对类 &lt;code&gt;ParticleModel&lt;/code&gt; 的覆盖，那么编译器就会关闭对其所有 &lt;code&gt;private&lt;/code&gt; 成员的动态调度，取而代之以更加快速的直接访问。
Assuming there is no class overriding ParticleModel in the current file, the compiler can replace all dynamically dispatched calls to private declarations with direct calls.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ParticleModel {
  private var point = ( x: 0.0, y: 0.0 )
  private var velocity = 100.0

  private func updatePoint(newPoint: (Double, Double), newVelocity: Double) {
    point = newPoint
    velocity = newVelocity
  }

  func update(newP: (Double, Double), newV: Double) {
    updatePoint(newP, newVelocity: newV)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码中，&lt;code&gt;point&lt;/code&gt;，&lt;code&gt;velocity&lt;/code&gt; 和 &lt;code&gt;updatePoint()&lt;/code&gt; 将被直接访问和调用。由于 &lt;code&gt;update()&lt;/code&gt; 没有被 &lt;code&gt;private&lt;/code&gt; 修饰，它仍然需要被动态调度。&lt;/p&gt;

&lt;p&gt;和 &lt;code&gt;final&lt;/code&gt; 一样，&lt;code&gt;private&lt;/code&gt; 也可以被用来直接修饰整个类声明，这相当于在该类的所有成员声明面前加了 &lt;code&gt;private&lt;/code&gt; 关键字。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;private class ParticleModel {
  var point = ( x: 0.0, y: 0.0 )
  var velocity = 100.0
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;通过模块级的优化来对 &lt;code&gt;internal&lt;/code&gt; 声明推导出 &lt;code&gt;final&lt;/code&gt; 语义&lt;/h1&gt;

&lt;p&gt;在 Swift 中，所有声明的可见性默认为 &lt;code&gt;internal&lt;/code&gt;，也就是说他们只能在定义他们的模块内可见。编译器通常会单独的编译模块内的每个文件，因此它在变异某一个源文件时，无法判断在同意模块内的其他源文件里是否对该源文件内定义的 &lt;code&gt;internal&lt;/code&gt; 声明的覆盖。但是如果我们启用了编译器的 &lt;code&gt;Whole Module Optimization&lt;/code&gt; 模块级优选项，所以的文件将在一次编译过程中全部被编译。这样编译器就能在整个模块范围类分析是否某个 &lt;code&gt;internal&lt;/code&gt; 声明被覆盖了，从而推导出 &lt;code&gt;final&lt;/code&gt; 语义以关闭动态调度特性。&lt;/p&gt;

&lt;p&gt;让我们回到最开始的代码，这回我们额外添加一些 &lt;code&gt;public&lt;/code&gt; 关键到 &lt;code&gt;ParticleModel&lt;/code&gt; 的声明中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public class ParticleModel {
  var point = ( x: 0.0, y: 0.0 )
  var velocity = 100.0

  func updatePoint(newPoint: (Double, Double), newVelocity: Double) {
    point = newPoint
    velocity = newVelocity
  }

  public func update(newP: (Double, Double), newV: Double) {
    updatePoint(newP, newVelocity: newV)
  }
}

var p = ParticleModel()
for i in stride(from: 0.0, through: times, by: 1.0) {
  p.update((i * sin(i), i), newV:i*1000)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当开启了模块级优化选项的编译器处理以上代码时，它能够推导出 &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;velocity&lt;/code&gt; 和 &lt;code&gt;updatePoint()&lt;/code&gt; 方法可以关闭动态调度特性。与此相反，由于 &lt;code&gt;update()&lt;/code&gt; 被 &lt;code&gt;public&lt;/code&gt; 修饰，其可见性延伸到了模块之外，所以编译器无法断定它具有 &lt;code&gt;final&lt;/code&gt; 语义。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift 官博文章翻译 - 内存安全：确保值在使用前先初始化</title>
      <link>http://localhost:1313/post/translation_swift_memory_safety/</link>
      <pubDate>Tue, 28 Apr 2015 23:03:56 CST</pubDate>
      
      <guid>http://localhost:1313/post/translation_swift_memory_safety/</guid>
      <description>

&lt;p&gt;原文链接：&lt;a href=&#34;https://developer.apple.com/swift/blog/?id=28&#34;&gt;Memory Safety: Ensuring Values are Initialized Before Use&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译者：Mudox&lt;/p&gt;

&lt;p&gt;我们设计 Swift 这门语言时的一个重要的发力方向就是改进编程模型的内存安全性。内存安全有很多方面，本文将由浅入深，先从一个简单的问题开始：如果确保值在使用前被初始化。&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Swift 的方式&lt;/h1&gt;

&lt;p&gt;如果每当一个变量第一次被访问时，该变量都有一个有效的初始值，那么该变量就被认为是“安全”的。不同的语言采用了不同的方式来提供这种安全性。比如 C 语言，它将责任完全交给程序员——这种方法强大，但是也很有难度。C++ 和 Objective-C 通过施加一些强制性的模式来改善此类情况，还有一些语言则（比较极端的）要求变量在定义时就必须初始化。&lt;/p&gt;

&lt;p&gt;Swift 采用的主要技术是通过其先进的编译器来对代码的数据流进行分析。由编译器在编译时确保变量在使用前正确初始化，这是是一种名为 &lt;a href=&#34;http://en.wikipedia.org/wiki/Definite_assignment_analysis&#34;&gt;明确初始化——Definitive Initialization&lt;/a&gt; 的策略。还有很多语言比如 Java，C# 都采用了类似的策略，而 Swift 则是的该策略的一个扩展版本应用于更大范围的变量上面。&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;本地变量的明确初始化&lt;/h1&gt;

&lt;p&gt;在 Swift 中有很多场景都用到了该策略，其中最简单的场景就是用于本地变量。相较于“隐式的默认值初始化 implicit default initialization”，明确初始化初始化提供了更大的灵活性，因为它运行你写出如下的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var myInstance : MyClass  // Uninitialized non-nullable class reference

if x &amp;gt; 42 {
  myInstance = MyClass(intValue: 13)
} else {
  myInstance = MyClass(floatValue: 92.3)
}

// Okay because myInstance is initialized on all paths
myInstance.printIt()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里编译器能分析出 &lt;code&gt;if&lt;/code&gt; 语言的两个分支里都对变量 &lt;code&gt;myInstance&lt;/code&gt; 做了初始化，因此它确信后面的 &lt;code&gt;printIt()&lt;/code&gt; 方法不会被调用于未初始化的内存上面。&lt;/p&gt;

&lt;p&gt;明确初始化策非常强大，但是它只有在代码可靠并可预测的情况下才能发挥作用。当你的代码的控制流逻辑比较复杂时，它就可能出意外。比如如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var myInstance : MyClass

if x &amp;gt; 10 {
  myInstance = MyClass(intValue: 13)
}
// ...
if x &amp;gt; 42 {
  myInstance.printIt()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码运行时，编译器会发出警告：“变量 &lt;code&gt;myInstance&lt;/code&gt; 在使用前未初始化”。这是因为编译器并不能分析出上下两个 if 语句的条件之间的内在逻辑关系。尽管我们能让编译器照顾到此类个别特殊情况，但是它还是不可能覆盖所有的特殊情况（这其实就是所谓的“&lt;a href=&#34;http://en.wikipedia.org/wiki/Halting_problem&#34;&gt;停机问题 halting problem&lt;/a&gt;”），因此我们决定保持编译规则简单可预测。&lt;/p&gt;

&lt;p&gt;Swift 使初始化一个变量变得极其简单。事实上用 Swift 在声明时给出初始化值 &lt;code&gt;var x = 0&lt;/code&gt; 比声明一个未初始化的变量 &lt;code&gt;var x: Int&lt;/code&gt; 所得到的代码更简短。Swift 提倡在任何可能的时候给声明的变量一个明确的初始化值。还有更加强大的方法就是通过调用 &lt;code&gt;init()&lt;/code&gt; 方法来初始化一个变量。想要了解更加详细的信息，请参阅 Swfit Programming Language 的“&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html&#34;&gt;初始化 Initialization&lt;/a&gt;” 一章。&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;其他的方式&lt;/h1&gt;

&lt;p&gt;除了明确初始化之外，Swift 在特定情况下也会采用一些其他的策略。您很可能已经在其他语言中碰到过这些策略，因此我们将在本文中简短的介绍下他们。他们都用各自不足之处，所以 Swift 并没有将他们当做主要策略来使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;将安全性交给程序员&lt;/strong&gt;：鉴于 C 的普及程度，我们有必要了解下简单的将安全性责任交给程序员这种做法的利与弊。在 C 中使用未经初始化的值会导致&lt;a href=&#34;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html&#34;&gt;不确定的行为 undefined behavior&lt;/a&gt;，经常表现为程序的运行时异常。C 语言依赖程序永远都不要犯错误。我们设计 Swift 语言的初衷之一就是让它从本质上就是安全的，所以这一策略果断被我们排除于绝大部分情况之外。但是，Swift 还是提供了诸如 &lt;code&gt;UnsafePointer&lt;/code&gt; 这样的 API，以允许你再绝对必要的情况下启用这种策略。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;隐式的默认值初始化&lt;/strong&gt;：可以让编译器隐式的初始化一个值，以确保其安全性。比如，在 Objective-C 中，给实例的成员变量设置一个初始的“零值”，或者像 C++ 那样给类提供默认的初始化器。我们曾深入探索过这一方法，但做种决定不广泛使用它。因为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;它对与那些没有合理初始化值的类型不起作用，比如 protocol 对象并没有 &lt;code&gt;init()&lt;/code&gt; 方法可以调用，已经在 Swift 非常普遍的不可为空的类引用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;就算是对于基本类型，比如对于一个 integer 变量，0 常常在上下文中是一个不合理的值。这也是为什么在 Swift 中给变量赋初始化值如此容易的原因之一。此外，这让代码对于后续的维护者更加的清晰明了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：对于 &lt;code&gt;Optional&lt;/code&gt; 和 &lt;code&gt;ImplicitlyUnwrappedOptional&lt;/code&gt; 这类可以为空的值，把他们默认初始化为空 &lt;code&gt;nil&lt;/code&gt; 是理所当然的。因此在 Swift 中所有飞空值都会被自动初始化为空值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;强制在定义时初始化&lt;/strong&gt;：强制要求程序在定义变量是给与其初始值，意味着 &lt;code&gt;var x: Int&lt;/code&gt; 将是非法的，因为它没有提供初始值给编译器。尽管该策略通用于函数式编程语言中, 但是我们认为这一要求国语严格而没有必要，也妨碍了程序员对自然模式的表达。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - AMAP API DEPICTED</title>
      <link>http://localhost:1313/note/ios_notes_amap/</link>
      <pubDate>Tue, 28 Apr 2015 17:43:56 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_amap/</guid>
      <description>

&lt;p&gt;AMap (高德地图) APIs depicted in several graphs I draw.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;AMap Searching API&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/amap_searching_graph.svg&#34; alt=&#34;AMap Searching API Graph&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - LOCATION BASED SERVIES</title>
      <link>http://localhost:1313/note/ios_notes_lbs/</link>
      <pubDate>Fri, 17 Apr 2015 14:43:56 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_lbs/</guid>
      <description>

&lt;p&gt;Quick steps to use iOS&amp;rsquo;s LBS technology.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Core Location&lt;/h1&gt;

&lt;p&gt;iOS devices integrates various hardware components, such as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;GPS (Global Positioning System) for positioning&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hardware compass for heading monitoring.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;WiFi for positioning.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Cellular network for cell-tower triangulation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Blue tooth for iBeacon ranging.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;some data sensors for improve positioning accuracy under some circumstances.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;to provides users with following LBS abilities as much as possible:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Location Updates&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Standard location updates&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Significant location updates&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Heading monitoring&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Region monitoring&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;iBeacon ranging&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Visit events&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The &lt;code&gt;CLLocationManager&lt;/code&gt; acts just like an &lt;code&gt;NSNotificationCenter&lt;/code&gt; (but it is not
a singleton) between the LBS hardwares and your App, you use it to request the
authorization for LBS functionalities you are planning to use afterwords, and
adjusts the relevant parameters of them before starting their notification
updating loops.&lt;/p&gt;

&lt;p&gt;After you call one of its&amp;rsquo; &lt;code&gt;start***&lt;/code&gt; or &lt;code&gt;request***&lt;/code&gt; methods to emit requests
for one of the 5 LBS abilities mentioned above, the &lt;code&gt;CLLocationManager&lt;/code&gt;
activate relevant hardware components, when the data is available it notifies
you asynchronously by calling one of the its&amp;rsquo; delegate&amp;rsquo;s methods.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/core_location_map.svg&#34; alt=&#34;Core Location Map&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Work flow of using LBS abilities.&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Project setup&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Enable &lt;em&gt;Background Location Updates Background Mode&lt;/em&gt; capability.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add &lt;em&gt;NSLocationAlwaysUsageDescriptions&lt;/em&gt; or
&lt;em&gt;NSLocationWhenInUseUsageDescription&lt;/em&gt; key to info.plist.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Configuring &lt;code&gt;CLLocationManager&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Creating a &lt;code&gt;CllocationManager&lt;/code&gt; instance and hold a strong reference to it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Specify location manager&amp;rsquo;s delegate, usually be a view controller.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check &amp;amp; request authorization status.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Configures the relevant properties for the LBS functionality you are about
to use.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Before starting each LBS updating functions, there are also corresponding
APIs you can invoke to check the services availability.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Call &lt;code&gt;start**&lt;/code&gt; methods to start the various LBS notification loops.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// declare as some long-standing reference outside of function body.
let locationManager = CLLocationManager()
--------------------
// within functions ( be it in viewDidLoad() )
// designate delegate
locationManager.delegate = self
// request for authorization
locationManager.requestAlwaysAuthorization()
// configure updating related settings
locationManager.activityType = .AutomotiveNavigation
locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation
locationManager.distanceFilter = 10
// finally check device &amp;amp; service availability before starting notification loop.
if CLLocationManager.locationServicesEnabled() {
  locationManager.startUpdatingLocation()
} else {
  let alert = UIAlertController(
    title: &amp;quot;Service Not Available&amp;quot;,
    message: &amp;quot;The location is not available or has been shut down.&amp;quot;,
    preferredStyle: .Alert)
  presentViewController(alert, animated: true, completion: nil)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Implement &lt;code&gt;CLLocationManagerDelegate&lt;/code&gt; methods in you designated delegate
object to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;handle received location data updates.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;handle LBS failures.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;handle authorization status changes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;hellip;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;MapKit&lt;/h1&gt;

&lt;p&gt;In general, MapKit:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;shows map in one of three map types:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Standard&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Satellite&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hybrid&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;along with many built-in elements:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;compass&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;POIs (points of interest)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;and provides developer with two kinds of customizable presentation
facilities:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;annotations&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;overlays&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As of managing annotations, MapKit adopts the same design pattern as that is
heavily used by &lt;code&gt;UITableView&lt;/code&gt; &amp;ndash; decoupling data model from presentation tools
through &lt;strong&gt;reuse pool&lt;/strong&gt;. Hence, there comes separate class hierarchies for
storing annotation (overlay) data, and presenting them respectively.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;data object&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;all objects that conforms to &lt;code&gt;MKAnnotation&lt;/code&gt; protocol, are responsible for
storing data for annotations, such as location, textual info, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;all objects that conforms to &lt;code&gt;MKOverlay&lt;/code&gt; protocol, are responsible for
storing data for overlays, such as location, etc.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;presentation tools&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;instances that inherit from &lt;code&gt;MKAnnotationView&lt;/code&gt; can be &lt;strong&gt;reused&lt;/strong&gt; to display a data objects.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;instances that inherit from &lt;code&gt;MKOverlayRenderer&lt;/code&gt; can be used to display a overlay objects.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/map_kit_map.svg&#34; alt=&#34;MapKit map&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Customize annotation view&lt;/h2&gt;

&lt;p&gt;A annotation view usually consist of 2 parts:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The view view.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Set its&amp;rsquo; &lt;code&gt;image&lt;/code&gt; property to change its&amp;rsquo; appearance.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The callout view, which is popped up when the pin view is selected.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The built-in callout view is not exposed for customization, so we should disable the &lt;code&gt;canShowCallout&lt;/code&gt; property&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - CASTING</title>
      <link>http://localhost:1313/note/ios_notes_casting/</link>
      <pubDate>Sun, 12 Apr 2015 14:43:56 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_casting/</guid>
      <description>

&lt;p&gt;Collect all my gain from study &amp;amp; using Swift&amp;rsquo;s casting mechanism here.&lt;/p&gt;

&lt;p&gt;First defining a sample class hierarchy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class SuperClass {
  func say() {
    println(&amp;quot;super class&amp;quot;)
  }
}

class Subclass: SuperClass {
  override func say() {
    println(&amp;quot;subclass&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;3 Kinds of Castings&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Natural Casting&lt;/p&gt;

&lt;p&gt;Used in &lt;strong&gt;up-casting&lt;/strong&gt; (i.e. casting from a sub-class instance to a super
class instance)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var a = SubClass()
var b = a as SuperClass
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unconditional Casting (or forced casting)&lt;/p&gt;

&lt;p&gt;Used in &lt;strong&gt;down-casting&lt;/strong&gt; (i.e. the contrary of the above).&lt;/p&gt;

&lt;p&gt;When the casting failed, it would incur a panic.&lt;/p&gt;

&lt;p&gt;Use it when you are confident about the down-casting.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conditional Casting&lt;/p&gt;

&lt;p&gt;Used in &lt;strong&gt;down-casting&lt;/strong&gt;, but it always returns optionals whether succeed
or fail, that means when not
applicalbe, instead of emitting a panic, it returns nil.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Conclusion:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Natural casting is used in &lt;em&gt;always-succeed&lt;/em&gt; castings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conditional &amp;amp; Unconditional castings are used in &lt;em&gt;might-fail&lt;/em&gt; castings.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;2 Operator for Casting&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;is&lt;/code&gt; operator&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;code&gt;as&lt;/code&gt; operators - &lt;code&gt;as&lt;/code&gt;, &lt;code&gt;as?&lt;/code&gt;, &lt;code&gt;as!&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Special casting scenarios in practice&lt;/h1&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Protocol Casting&lt;/h2&gt;

&lt;p&gt;In Swift the relationship between a protocol and the classes adopting that
protocol is like the relationship between a super class and its&amp;rsquo; sub-classes.
Hence casting a protocol object, such as the &lt;code&gt;AnyObject&lt;/code&gt; to its&amp;rsquo; underlying
class is regarded as a down-casting.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit // import AppKit

let a: AnyObject = &amp;quot;String&amp;quot;
let b: a as! String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are 3 special types: &lt;code&gt;Any&lt;/code&gt;, &lt;code&gt;AnyObject&lt;/code&gt;, &lt;code&gt;AnyClass&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;By tracing the source code, you would find the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;/// The protocol to which all classes implicitly conform.
///
/// When used as a concrete type, all known `@objc` methods and
/// properties are available, as implicitly-unwrapped-optional methods
/// and properties respectively, on each instance of `AnyObject`.
@objc procotol AnyObject {}

/// The protocol to which all class types implicitly conform.
///
/// When used as a concrete type, all known `@objc` `class` methods and
/// properties are available, as implicitly-unwrapped-optional methods
/// and properties respectively, on each instance of `AnyClass`.
typealias AnyClass = AnyObject.Type

/// The protocol to which all types implicitly conform
typealias Any = protocol&amp;lt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There exists a prerequisite for the rules all above: the &lt;code&gt;Foundation&lt;/code&gt; framework
must be imported. (Usually, you import &lt;code&gt;UIKit&lt;/code&gt; or &lt;code&gt;AppKit&lt;/code&gt;, which implicitly
import &lt;code&gt;Foundation&lt;/code&gt; framework). Only then can swift compiler be able to
recognize the &lt;code&gt;@objc&lt;/code&gt; keyword, and have Objective-C type bridging ability.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Optional AnyObject Collection Casting&lt;/h2&gt;

&lt;p&gt;For a optional of Collection of AnyObject that reference objects of the same
class (or super class) T, can be [un]conditionally casted to [T] (without
being wrapped in optional anymore)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit // import Appkit

// optional array of String.
let a: [AnyObject]? = [&amp;quot;Newyork&amp;quot;, &amp;quot;London&amp;quot;, &amp;quot;Peking&amp;quot;]
let b = a as! [String] // succeed.

// optional array of mixed object that have no common super class.
let a: [AnyObject]? = [&amp;quot;Newyork&amp;quot;, 1983, 3.14, false]
let b = a as! [String] // fail: not all element are of String.

// optinal array of mixed objects that derived from the same super class.
let a: [AnyObject]? = [Subclass(), SuperClass(), SuperClass(), Subclass()]
let b = a as! [Subclass] // succeed: not all element are of String.

// implicitly unwrapped optional dictionary with String typped keys and Int typed values.
let a: [NSObject: AnyObject]! = [&amp;quot;id1&amp;quot;: 32, &amp;quot;id2&amp;quot;: 66]
if let b = a as? [String: Int] {
  println(b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code list above, the String is a structure type in Swift (no a class
type), but it can also be referenced by a &lt;code&gt;AnyObject&lt;/code&gt; instance. The rules come
from the following excerpt from &amp;ldquo;Using Swift with Cocoa and Objective-C&amp;rdquo;
official document:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An object is AnyObject compatible if it is an instance of an Objective-C or
Swift class, or if the object can be bridged to one.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There exist several swift - Objective-C type bridging depicted as follows:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/swift_objc_bridging.svg&#34; alt=&#34;Siwft - Objective-C Bridging&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Hence, back to the code listing above, the Swift type &lt;code&gt;String&lt;/code&gt; can be bridged
to NSString &lt;code&gt;Foundation&lt;/code&gt; class, then it is &lt;code&gt;AnyObject&lt;/code&gt; compatible.&lt;/p&gt;

&lt;p&gt;In practice, there exists quit a few occasions that you need to cast optional
collections to type specific Swift collections to utilize their underlying
methods or properties.&lt;/p&gt;

&lt;p&gt;For example, when you invoke the Objective-C APIs that return &lt;code&gt;NSArray&lt;/code&gt;,
&lt;code&gt;NSDictionary&lt;/code&gt;, &lt;code&gt;NSSet&lt;/code&gt;, you would get &lt;code&gt;[AnyOject]!&lt;/code&gt; &lt;code&gt;[NSObject: AnyOject]!&lt;/code&gt;,
&lt;code&gt;[NSObject]!&lt;/code&gt; respectively, you could cast [un]conditionally to a more concrete
Swift collection type before you access the individual elements within they.&lt;/p&gt;

&lt;p&gt;When you use &lt;code&gt;as!&lt;/code&gt; (the unconditional casting), you got an unwrapped collection
in one line of code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let asset: AVURLAsset = ...
for meta in asset.commonMetadata as! [AVMetadataItem] {
  switch meta.commonKey {
  case AVMetadataCommonKeyTitle:
    item.title = meta.stringValue
  case AVMetadataCommonKeyArtist:
    item.artist = meta.stringValue
  case AVMetadataCommonKeyAlbumName:
    item.albumName = meta.stringValue
  case AVMetadataCommonKeyArtwork:
    switch meta.value {
    case let data as NSData:
      item.artwork = UIImage(data: data)
    case let dict as [NSObject: AnyObject]:
      item.artwork = UIImage(data: dict[&amp;quot;data&amp;quot;] as! NSData)
    default:
      assert(false, &amp;quot;Invalid metadata value type&amp;quot;)
    }
  default:
    break
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - KEYBOARD</title>
      <link>http://localhost:1313/note/ios_notes_keyboard/</link>
      <pubDate>Wed, 08 Apr 2015 16:19:59 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_keyboard/</guid>
      <description>

&lt;p&gt;Handle iOS keyboard poppu &amp;amp; resignment gracefully.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;UIWindow provide 6 keyboard related notifications&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;UIKeyboard[Will/Did]ShowNotification&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIKeyboard[Will/Did]HideNotification&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIKeyboard[Will/Did]ChangeFrameNotification&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After playing with these notifications above, I found:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;When you want to move obscured contents or views to above the keyboard, put
the frame adjustment code in *&lt;strong&gt;Will&lt;/strong&gt;* notifications, because the handler
methods seems to be invoked within the same animation block that provides
the keyboard revealing animation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you are only interested in tracing keyboard&amp;rsquo;s frame (more specifically the
height) during keyboard&amp;rsquo;s presence, monitoring
&lt;code&gt;UIKeyboardWillShowNotification&lt;/code&gt; seems enough, no need to monitoring
&lt;code&gt;UIKboardWillChangeFrameNotification&lt;/code&gt; additionally.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The frame size stored in &lt;code&gt;UIKeyboardFrameBeginUserInfoKey&lt;/code&gt; and
&lt;code&gt;UIKeyboardFrameEndUserInfoKey&lt;/code&gt; keys will only differ after keyboard is
first shown and before it is hidden. When the keyboard is first shown or is
resigned, the &lt;code&gt;Begin&lt;/code&gt; or &lt;code&gt;End&lt;/code&gt; frame is equal.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Strategies for move contents above the keyboard:&lt;/h1&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;For contents embedded in &lt;code&gt;UISCrollView&lt;/code&gt;s&lt;/h2&gt;

&lt;p&gt;Way #1 &amp;ndash; Adjust the bottom edge inset value of the containing scroll view&amp;rsquo;s
contentsInset property and scroll active view into visible area using
&lt;code&gt;scrollRectToVisible: animated:&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;Way #2 &amp;ndash; Adjust containing scroll view&amp;rsquo;s contentSize &amp;amp; contentOffset
properties.&lt;/p&gt;

&lt;p&gt;No matter which way above you choose, remember to adjust
&lt;code&gt;scrollIndicatorInsets&lt;/code&gt;&amp;rsquo;s bottom edge inset value to make the indicator fully
un-obscured from the keyboard.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;For contents outside any &lt;code&gt;UIScrollView&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Recalculate and set its&amp;rsquo; frame.origin.y value in
&lt;code&gt;UIKeyboardWillShowNotification&lt;/code&gt; handler method, and the movement will be
animated along with the revealing of keyboard perfectly.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func handleKeyboardNotification(notify: NSNotification) {
  let value = notify.userInfo?[UIKeyboardFrameEndUserInfoKey] as NSValue
  let keyboardHeight = value.CGRectValue().height

  switch notify.name {

  case UIKeyboardWillShowNotification:
    theViewToMove.frame.origin.y = self.view.bounds.height - keyboardHeight - theViewToMoveMargin - theViewToMove.bounds.height
    theScrollViewToAdjust.contentInset.bottom = keyboardHeight
    itemsTable.scrollIndicatorInsets.bottom = keyboardHeight

  case UIKeyboardWillHideNotification:
    theViewToMove.frame.origin.y = self.view.bounds.height - theViewToMoveMargin - theViewToMove.bounds.height
    theScrollViewToAdjust.contentInset.bottom = 0.0
    itemsTable.scrollIndicatorInsets.bottom = 0.0 // the default value

  default:
    assert(false)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;References:&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/KeyboardManagement/KeyboardManagement.html#//apple_ref/doc/uid/TP40009542-CH5-SW7&#34;&gt;Moving Contents That is Located Under the Keyboard in Text Programming Guide for iOS&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIWindow_Class/&#34;&gt;UIWindow Class Reference&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - COCOA CONCURRENCY</title>
      <link>http://localhost:1313/note/ios_notes_cocoa_concurrency/</link>
      <pubDate>Wed, 24 Sep 2014 22:18:21 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_cocoa_concurrency/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Members Of Cocoa Concurrency&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Operation Queue&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;abstract base class &lt;code&gt;NSOperation&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;concrete subclass &lt;code&gt;NSInvocation&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;concrete subclass &lt;code&gt;NSBlockOperation&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Dispatch Queue&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Dispatch Source&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Operation Queue Features&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;graph-based dependencies&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;completion block&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;execution status monitoring&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;prioritizeing&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;canceling&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - COCOA THREADING</title>
      <link>http://localhost:1313/note/ios_notes_cocoa_threading/</link>
      <pubDate>Wed, 24 Sep 2014 21:19:59 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_cocoa_threading/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Run Loop&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;4 roles participate in the run loop game:&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Run Loop&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;which is represented by &lt;code&gt;NSRun Loop&lt;/code&gt; &amp;amp; &lt;code&gt;CFRunLoop&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Run Loop Mode&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;which is represented by &lt;code&gt;CFStringRef&lt;/code&gt; associated to each instance of run
loop object.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Run Loop Source&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;which is represented by &lt;code&gt;CFRunloopSource&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Input source&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Port-based source&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perform selctor on other threads&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Custom source&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Timer&lt;/p&gt;

&lt;p&gt;which is represented by &lt;code&gt;CFRunloopTimerRef&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Explictly defined timer&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perform selector on current thread with delay&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perform selector&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Run Loop Observer&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;4 ways to kill a run loop iteration:&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;no sources exists&lt;/p&gt;

&lt;p&gt;since some system routines may install certain input sources to the run
 loop implictly, we should not kill a run loop iteration by clearing &amp;lsquo;&lt;em&gt;all&lt;/em&gt;&amp;lsquo;
 sources we known.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;timeout&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sourced handled in one-shot mode&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;explicitly stoped by &lt;code&gt;CRunloopStop&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;3 kinds of perform selector sources.&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;on thread&lt;/th&gt;
&lt;th&gt;invocation&lt;/th&gt;
&lt;th&gt;delay&lt;/th&gt;
&lt;th&gt;blocking call?&lt;/th&gt;
&lt;th&gt;mode&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;current thread&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;always non-blocking&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;other thread&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;main thread&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Alternatives To Threaing&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Operation Objects&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Grand Central Dispatch (GCD)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Idle-time notifications&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Asynchronous functions&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Timers&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Separate processes&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Cocoa Support For Threading&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Cocoa threads&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;POSIX threads&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;del&gt;Mutiprocessing Services&lt;/del&gt; (&lt;em&gt;obsolete&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;Inter-Thread Communication&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Direct messageing&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Global variables, shared memory &amp;amp; objects&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conditions&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Run loop sources&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ports &amp;amp; sockets&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;del&gt;Message queues&lt;/del&gt; (&lt;em&gt;obsolete&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Cocoa distributed objects&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;Synchronization Tools&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Atomic operation&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;atomic add&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atomic increment&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atomic decrement&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;compare-and-swap&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;test-and-set&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;test-and-clear&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Memory barriers&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Volatile variables&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Locks&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Mutex&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;POSIX API provides &lt;code&gt;pthread_lock_t&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Cocoa provides &lt;code&gt;NSLock&lt;/code&gt; &amp;amp;  &lt;code&gt;@synchronized()&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Recursive lock&lt;/p&gt;

&lt;p&gt;which is provided as class &lt;code&gt;NSRecursiveLock&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Read-write lock (&lt;em&gt;pthread only&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Distributed lock&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Spin lock (&lt;em&gt;not implemented&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Double-checked lock&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conditions (aka &lt;em&gt;condition variable&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perform selector routines&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>