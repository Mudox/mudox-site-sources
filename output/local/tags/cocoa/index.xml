<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Cocoa on Mudox </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://localhost:1313/tags/cocoa/index.xml/</link>
    <language>en-us</language>
    
    
    <updated>Tue, 28 Apr 2015 17:43:56 CST</updated>
    
    <item>
      <title>iOS NOTES - AMAP API DEPICTED</title>
      <link>http://localhost:1313/note/ios_notes_amap/</link>
      <pubDate>Tue, 28 Apr 2015 17:43:56 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_amap/</guid>
      <description>

&lt;p&gt;AMap (高德地图) APIs depicted in several graphs I draw.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;AMap Searching API&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/amap_searching_graph.svg&#34; alt=&#34;AMap Searching API Graph&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - LOCATION BASED SERVIES</title>
      <link>http://localhost:1313/note/ios_notes_lbs/</link>
      <pubDate>Fri, 17 Apr 2015 14:43:56 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_lbs/</guid>
      <description>

&lt;p&gt;Quick steps to use iOS&amp;rsquo;s LBS technology.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Core Location&lt;/h1&gt;

&lt;p&gt;iOS devices integrates various hardware components, such as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;GPS (Global Positioning System) for positioning&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hardware compass for heading monitoring.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;WiFi for positioning.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Cellular network for cell-tower triangulation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Blue tooth for iBeacon ranging.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;some data sensors for improve positioning accuracy under some circumstances.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;to provides users with following LBS abilities as much as possible:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Location Updates&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Standard location updates&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Significant location updates&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Heading monitoring&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Region monitoring&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;iBeacon ranging&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Visit events&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The &lt;code&gt;CLLocationManager&lt;/code&gt; acts just like an &lt;code&gt;NSNotificationCenter&lt;/code&gt; (but it is not
a singleton) between the LBS hardwares and your App, you use it to request the
authorization for LBS functionalities you are planning to use afterwords, and
adjusts the relevant parameters of them before starting their notification
updating loops.&lt;/p&gt;

&lt;p&gt;After you call one of its&amp;rsquo; &lt;code&gt;start***&lt;/code&gt; or &lt;code&gt;request***&lt;/code&gt; methods to emit requests
for one of the 5 LBS abilities mentioned above, the &lt;code&gt;CLLocationManager&lt;/code&gt;
activate relevant hardware components, when the data is available it notifies
you asynchronously by calling one of the its&amp;rsquo; delegate&amp;rsquo;s methods.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/core_location_map.svg&#34; alt=&#34;Core Location Map&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Work flow of using LBS abilities.&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Project setup&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Enable &lt;em&gt;Background Location Updates Background Mode&lt;/em&gt; capability.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add &lt;em&gt;NSLocationAlwaysUsageDescriptions&lt;/em&gt; or
&lt;em&gt;NSLocationWhenInUseUsageDescription&lt;/em&gt; key to info.plist.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Configuring &lt;code&gt;CLLocationManager&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Creating a &lt;code&gt;CllocationManager&lt;/code&gt; instance and hold a strong reference to it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Specify location manager&amp;rsquo;s delegate, usually be a view controller.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check &amp;amp; request authorization status.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Configures the relevant properties for the LBS functionality you are about
to use.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Before starting each LBS updating functions, there are also corresponding
APIs you can invoke to check the services availability.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Call &lt;code&gt;start**&lt;/code&gt; methods to start the various LBS notification loops.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// declare as some long-standing reference outside of function body.
let locationManager = CLLocationManager()
--------------------
// within functions ( be it in viewDidLoad() )
// designate delegate
locationManager.delegate = self
// request for authorization
locationManager.requestAlwaysAuthorization()
// configure updating related settings
locationManager.activityType = .AutomotiveNavigation
locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation
locationManager.distanceFilter = 10
// finally check device &amp;amp; service availability before starting notification loop.
if CLLocationManager.locationServicesEnabled() {
  locationManager.startUpdatingLocation()
} else {
  let alert = UIAlertController(
    title: &amp;quot;Service Not Available&amp;quot;,
    message: &amp;quot;The location is not available or has been shut down.&amp;quot;,
    preferredStyle: .Alert)
  presentViewController(alert, animated: true, completion: nil)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Implement &lt;code&gt;CLLocationManagerDelegate&lt;/code&gt; methods in you designated delegate
object to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;handle received location data updates.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;handle LBS failures.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;handle authorization status changes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;hellip;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;MapKit&lt;/h1&gt;

&lt;p&gt;In general, MapKit:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;shows map in one of three map types:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Standard&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Satellite&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hybrid&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;along with many built-in elements:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;compass&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;POIs (points of interest)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;and provides developer with two kinds of customizable presentation
facilities:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;annotations&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;overlays&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As of managing annotations, MapKit adopts the same design pattern as that is
heavily used by &lt;code&gt;UITableView&lt;/code&gt; &amp;ndash; decoupling data model from presentation tools
through &lt;strong&gt;reuse pool&lt;/strong&gt;. Hence, there comes separate class hierarchies for
storing annotation (overlay) data, and presenting them respectively.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;data object&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;all objects that conforms to &lt;code&gt;MKAnnotation&lt;/code&gt; protocol, are responsible for
storing data for annotations, such as location, textual info, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;all objects that conforms to &lt;code&gt;MKOverlay&lt;/code&gt; protocol, are responsible for
storing data for overlays, such as location, etc.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;presentation tools&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;instances that inherit from &lt;code&gt;MKAnnotationView&lt;/code&gt; can be &lt;strong&gt;reused&lt;/strong&gt; to display a data objects.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;instances that inherit from &lt;code&gt;MKOverlayRenderer&lt;/code&gt; can be used to display a overlay objects.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/map_kit_map.svg&#34; alt=&#34;MapKit map&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Customize annotation view&lt;/h2&gt;

&lt;p&gt;A annotation view usually consist of 2 parts:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The view view.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Set its&amp;rsquo; &lt;code&gt;image&lt;/code&gt; property to change its&amp;rsquo; appearance.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The callout view, which is popped up when the pin view is selected.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The built-in callout view is not exposed for customization, so we should disable the &lt;code&gt;canShowCallout&lt;/code&gt; property&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - CASTING</title>
      <link>http://localhost:1313/note/ios_notes_casting/</link>
      <pubDate>Sun, 12 Apr 2015 14:43:56 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_casting/</guid>
      <description>

&lt;p&gt;Collect all my gain from study &amp;amp; using Swift&amp;rsquo;s casting mechanism here.&lt;/p&gt;

&lt;p&gt;First defining a sample class hierarchy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class SuperClass {
  func say() {
    println(&amp;quot;super class&amp;quot;)
  }
}

class Subclass: SuperClass {
  override func say() {
    println(&amp;quot;subclass&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;3 Kinds of Castings&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Natural Casting&lt;/p&gt;

&lt;p&gt;Used in &lt;strong&gt;up-casting&lt;/strong&gt; (i.e. casting from a sub-class instance to a super
class instance)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var a = SubClass()
var b = a as SuperClass
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unconditional Casting (or forced casting)&lt;/p&gt;

&lt;p&gt;Used in &lt;strong&gt;down-casting&lt;/strong&gt; (i.e. the contrary of the above).&lt;/p&gt;

&lt;p&gt;When the casting failed, it would incur a panic.&lt;/p&gt;

&lt;p&gt;Use it when you are confident about the down-casting.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conditional Casting&lt;/p&gt;

&lt;p&gt;Used in &lt;strong&gt;down-casting&lt;/strong&gt;, but it always returns optionals whether succeed
or fail, that means when not
applicalbe, instead of emitting a panic, it returns nil.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Conclusion:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Natural casting is used in &lt;em&gt;always-succeed&lt;/em&gt; castings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conditional &amp;amp; Unconditional castings are used in &lt;em&gt;might-fail&lt;/em&gt; castings.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;2 Operator for Casting&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;is&lt;/code&gt; operator&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;code&gt;as&lt;/code&gt; operators - &lt;code&gt;as&lt;/code&gt;, &lt;code&gt;as?&lt;/code&gt;, &lt;code&gt;as!&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Special casting scenarios in practice&lt;/h1&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Protocol Casting&lt;/h2&gt;

&lt;p&gt;In Swift the relationship between a protocol and the classes adopting that
protocol is like the relationship between a super class and its&amp;rsquo; sub-classes.
Hence casting a protocol object, such as the &lt;code&gt;AnyObject&lt;/code&gt; to its&amp;rsquo; underlying
class is regarded as a down-casting.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit // import AppKit

let a: AnyObject = &amp;quot;String&amp;quot;
let b: a as! String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are 3 special types: &lt;code&gt;Any&lt;/code&gt;, &lt;code&gt;AnyObject&lt;/code&gt;, &lt;code&gt;AnyClass&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;By tracing the source code, you would find the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;/// The protocol to which all classes implicitly conform.
///
/// When used as a concrete type, all known `@objc` methods and
/// properties are available, as implicitly-unwrapped-optional methods
/// and properties respectively, on each instance of `AnyObject`.
@objc procotol AnyObject {}

/// The protocol to which all class types implicitly conform.
///
/// When used as a concrete type, all known `@objc` `class` methods and
/// properties are available, as implicitly-unwrapped-optional methods
/// and properties respectively, on each instance of `AnyClass`.
typealias AnyClass = AnyObject.Type

/// The protocol to which all types implicitly conform
typealias Any = protocol&amp;lt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There exists a prerequisite for the rules all above: the &lt;code&gt;Foundation&lt;/code&gt; framework
must be imported. (Usually, you import &lt;code&gt;UIKit&lt;/code&gt; or &lt;code&gt;AppKit&lt;/code&gt;, which implicitly
import &lt;code&gt;Foundation&lt;/code&gt; framework). Only then can swift compiler be able to
recognize the &lt;code&gt;@objc&lt;/code&gt; keyword, and have Objective-C type bridging ability.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Optional AnyObject Collection Casting&lt;/h2&gt;

&lt;p&gt;For a optional of Collection of AnyObject that reference objects of the same
class (or super class) T, can be [un]conditionally casted to [T] (without
being wrapped in optional anymore)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit // import Appkit

// optional array of String.
let a: [AnyObject]? = [&amp;quot;Newyork&amp;quot;, &amp;quot;London&amp;quot;, &amp;quot;Peking&amp;quot;]
let b = a as! [String] // succeed.

// optional array of mixed object that have no common super class.
let a: [AnyObject]? = [&amp;quot;Newyork&amp;quot;, 1983, 3.14, false]
let b = a as! [String] // fail: not all element are of String.

// optinal array of mixed objects that derived from the same super class.
let a: [AnyObject]? = [Subclass(), SuperClass(), SuperClass(), Subclass()]
let b = a as! [Subclass] // succeed: not all element are of String.

// implicitly unwrapped optional dictionary with String typped keys and Int typed values.
let a: [NSObject: AnyObject]! = [&amp;quot;id1&amp;quot;: 32, &amp;quot;id2&amp;quot;: 66]
if let b = a as? [String: Int] {
  println(b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code list above, the String is a structure type in Swift (no a class
type), but it can also be referenced by a &lt;code&gt;AnyObject&lt;/code&gt; instance. The rules come
from the following excerpt from &amp;ldquo;Using Swift with Cocoa and Objective-C&amp;rdquo;
official document:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An object is AnyObject compatible if it is an instance of an Objective-C or
Swift class, or if the object can be bridged to one.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There exist several swift - Objective-C type bridging depicted as follows:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/swift_objc_bridging.svg&#34; alt=&#34;Siwft - Objective-C Bridging&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Hence, back to the code listing above, the Swift type &lt;code&gt;String&lt;/code&gt; can be bridged
to NSString &lt;code&gt;Foundation&lt;/code&gt; class, then it is &lt;code&gt;AnyObject&lt;/code&gt; compatible.&lt;/p&gt;

&lt;p&gt;In practice, there exists quit a few occasions that you need to cast optional
collections to type specific Swift collections to utilize their underlying
methods or properties.&lt;/p&gt;

&lt;p&gt;For example, when you invoke the Objective-C APIs that return &lt;code&gt;NSArray&lt;/code&gt;,
&lt;code&gt;NSDictionary&lt;/code&gt;, &lt;code&gt;NSSet&lt;/code&gt;, you would get &lt;code&gt;[AnyOject]!&lt;/code&gt; &lt;code&gt;[NSObject: AnyOject]!&lt;/code&gt;,
&lt;code&gt;[NSObject]!&lt;/code&gt; respectively, you could cast [un]conditionally to a more concrete
Swift collection type before you access the individual elements within they.&lt;/p&gt;

&lt;p&gt;When you use &lt;code&gt;as!&lt;/code&gt; (the unconditional casting), you got an unwrapped collection
in one line of code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let asset: AVURLAsset = ...
for meta in asset.commonMetadata as! [AVMetadataItem] {
  switch meta.commonKey {
  case AVMetadataCommonKeyTitle:
    item.title = meta.stringValue
  case AVMetadataCommonKeyArtist:
    item.artist = meta.stringValue
  case AVMetadataCommonKeyAlbumName:
    item.albumName = meta.stringValue
  case AVMetadataCommonKeyArtwork:
    switch meta.value {
    case let data as NSData:
      item.artwork = UIImage(data: data)
    case let dict as [NSObject: AnyObject]:
      item.artwork = UIImage(data: dict[&amp;quot;data&amp;quot;] as! NSData)
    default:
      assert(false, &amp;quot;Invalid metadata value type&amp;quot;)
    }
  default:
    break
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - KEYBOARD</title>
      <link>http://localhost:1313/note/ios_notes_keyboard/</link>
      <pubDate>Wed, 08 Apr 2015 16:19:59 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_keyboard/</guid>
      <description>

&lt;p&gt;Handle iOS keyboard poppu &amp;amp; resignment gracefully.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;UIWindow provide 6 keyboard related notifications&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;UIKeyboard[Will/Did]ShowNotification&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIKeyboard[Will/Did]HideNotification&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIKeyboard[Will/Did]ChangeFrameNotification&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After playing with these notifications above, I found:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;When you want to move obscured contents or views to above the keyboard, put
the frame adjustment code in *&lt;strong&gt;Will&lt;/strong&gt;* notifications, because the handler
methods seems to be invoked within the same animation block that provides
the keyboard revealing animation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you are only interested in tracing keyboard&amp;rsquo;s frame (more specifically the
height) during keyboard&amp;rsquo;s presence, monitoring
&lt;code&gt;UIKeyboardWillShowNotification&lt;/code&gt; seems enough, no need to monitoring
&lt;code&gt;UIKboardWillChangeFrameNotification&lt;/code&gt; additionally.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The frame size stored in &lt;code&gt;UIKeyboardFrameBeginUserInfoKey&lt;/code&gt; and
&lt;code&gt;UIKeyboardFrameEndUserInfoKey&lt;/code&gt; keys will only differ after keyboard is
first shown and before it is hidden. When the keyboard is first shown or is
resigned, the &lt;code&gt;Begin&lt;/code&gt; or &lt;code&gt;End&lt;/code&gt; frame is equal.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Strategies for move contents above the keyboard:&lt;/h1&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;For contents embedded in &lt;code&gt;UISCrollView&lt;/code&gt;s&lt;/h2&gt;

&lt;p&gt;Way #1 &amp;ndash; Adjust the bottom edge inset value of the containing scroll view&amp;rsquo;s
contentsInset property and scroll active view into visible area using
&lt;code&gt;scrollRectToVisible: animated:&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;Way #2 &amp;ndash; Adjust containing scroll view&amp;rsquo;s contentSize &amp;amp; contentOffset
properties.&lt;/p&gt;

&lt;p&gt;No matter which way above you choose, remember to adjust
&lt;code&gt;scrollIndicatorInsets&lt;/code&gt;&amp;rsquo;s bottom edge inset value to make the indicator fully
un-obscured from the keyboard.&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;For contents outside any &lt;code&gt;UIScrollView&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Recalculate and set its&amp;rsquo; frame.origin.y value in
&lt;code&gt;UIKeyboardWillShowNotification&lt;/code&gt; handler method, and the movement will be
animated along with the revealing of keyboard perfectly.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func handleKeyboardNotification(notify: NSNotification) {
  let value = notify.userInfo?[UIKeyboardFrameEndUserInfoKey] as NSValue
  let keyboardHeight = value.CGRectValue().height

  switch notify.name {

  case UIKeyboardWillShowNotification:
    theViewToMove.frame.origin.y = self.view.bounds.height - keyboardHeight - theViewToMoveMargin - theViewToMove.bounds.height
    theScrollViewToAdjust.contentInset.bottom = keyboardHeight
    itemsTable.scrollIndicatorInsets.bottom = keyboardHeight

  case UIKeyboardWillHideNotification:
    theViewToMove.frame.origin.y = self.view.bounds.height - theViewToMoveMargin - theViewToMove.bounds.height
    theScrollViewToAdjust.contentInset.bottom = 0.0
    itemsTable.scrollIndicatorInsets.bottom = 0.0 // the default value

  default:
    assert(false)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;References:&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/KeyboardManagement/KeyboardManagement.html#//apple_ref/doc/uid/TP40009542-CH5-SW7&#34;&gt;Moving Contents That is Located Under the Keyboard in Text Programming Guide for iOS&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIWindow_Class/&#34;&gt;UIWindow Class Reference&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - COCOA CONCURRENCY</title>
      <link>http://localhost:1313/note/ios_notes_cocoa_concurrency/</link>
      <pubDate>Wed, 24 Sep 2014 22:18:21 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_cocoa_concurrency/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Members Of Cocoa Concurrency&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Operation Queue&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;abstract base class &lt;code&gt;NSOperation&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;concrete subclass &lt;code&gt;NSInvocation&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;concrete subclass &lt;code&gt;NSBlockOperation&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Dispatch Queue&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Dispatch Source&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Operation Queue Features&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;graph-based dependencies&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;completion block&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;execution status monitoring&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;prioritizeing&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;canceling&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - COCOA THREADING</title>
      <link>http://localhost:1313/note/ios_notes_cocoa_threading/</link>
      <pubDate>Wed, 24 Sep 2014 21:19:59 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_cocoa_threading/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;Run Loop&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;4 roles participate in the run loop game:&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Run Loop&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;which is represented by &lt;code&gt;NSRun Loop&lt;/code&gt; &amp;amp; &lt;code&gt;CFRunLoop&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Run Loop Mode&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;which is represented by &lt;code&gt;CFStringRef&lt;/code&gt; associated to each instance of run
loop object.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Run Loop Source&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;which is represented by &lt;code&gt;CFRunloopSource&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Input source&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Port-based source&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perform selctor on other threads&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Custom source&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Timer&lt;/p&gt;

&lt;p&gt;which is represented by &lt;code&gt;CFRunloopTimerRef&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Explictly defined timer&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perform selector on current thread with delay&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perform selector&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Run Loop Observer&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;4 ways to kill a run loop iteration:&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;no sources exists&lt;/p&gt;

&lt;p&gt;since some system routines may install certain input sources to the run
 loop implictly, we should not kill a run loop iteration by clearing &amp;lsquo;&lt;em&gt;all&lt;/em&gt;&amp;lsquo;
 sources we known.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;timeout&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sourced handled in one-shot mode&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;explicitly stoped by &lt;code&gt;CRunloopStop&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;3 kinds of perform selector sources.&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;on thread&lt;/th&gt;
&lt;th&gt;invocation&lt;/th&gt;
&lt;th&gt;delay&lt;/th&gt;
&lt;th&gt;blocking call?&lt;/th&gt;
&lt;th&gt;mode&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;current thread&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;always non-blocking&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;other thread&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;main thread&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Alternatives To Threaing&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Operation Objects&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Grand Central Dispatch (GCD)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Idle-time notifications&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Asynchronous functions&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Timers&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Separate processes&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Cocoa Support For Threading&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Cocoa threads&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;POSIX threads&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;del&gt;Mutiprocessing Services&lt;/del&gt; (&lt;em&gt;obsolete&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;Inter-Thread Communication&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Direct messageing&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Global variables, shared memory &amp;amp; objects&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conditions&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Run loop sources&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ports &amp;amp; sockets&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;del&gt;Message queues&lt;/del&gt; (&lt;em&gt;obsolete&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Cocoa distributed objects&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;Synchronization Tools&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Atomic operation&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;atomic add&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atomic increment&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atomic decrement&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;compare-and-swap&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;test-and-set&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;test-and-clear&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Memory barriers&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Volatile variables&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Locks&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Mutex&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;POSIX API provides &lt;code&gt;pthread_lock_t&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Cocoa provides &lt;code&gt;NSLock&lt;/code&gt; &amp;amp;  &lt;code&gt;@synchronized()&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Recursive lock&lt;/p&gt;

&lt;p&gt;which is provided as class &lt;code&gt;NSRecursiveLock&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Read-write lock (&lt;em&gt;pthread only&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Distributed lock&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Spin lock (&lt;em&gt;not implemented&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Double-checked lock&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conditions (aka &lt;em&gt;condition variable&lt;/em&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perform selector routines&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>