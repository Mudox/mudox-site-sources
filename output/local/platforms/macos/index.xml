<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Macos on Mudox </title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://localhost:1313/platforms/macos/index.xml/</link>
    <language>en-us</language>
    
    
    <updated>Thu, 30 Apr 2015 15:03:56 CST</updated>
    
    <item>
      <title>Swift 官博文章翻译 - 可为空性和 Objective-C</title>
      <link>http://localhost:1313/post/trans_swift_nullability_and_objective_c/</link>
      <pubDate>Thu, 30 Apr 2015 15:03:56 CST</pubDate>
      
      <guid>http://localhost:1313/post/trans_swift_nullability_and_objective_c/</guid>
      <description>

&lt;p&gt;原文链接：&lt;a href=&#34;https://developer.apple.com/swift/blog/?id=25&#34;&gt;Nullability and Objective-C&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译者：Mudox&lt;/p&gt;

&lt;p&gt;Swift 语言的一个很棒的特性就是它能透明的和 Objective-C 代码互操作，不管是系统提供 Objective-C 框架还是那些你自己写的代码都能。然而，在 Swift 中，可为空的值与不可为空的值引用之间使用明显区别的。比如说 &lt;code&gt;NSView&lt;/code&gt; 和 &lt;code&gt;NSView?&lt;/code&gt; 在 Swift 中是两个截然不同的类型，但在 Objective-C 中他们都用 &lt;code&gt;NSView *&lt;/code&gt; 表示。由于 Swift 无法判断 &lt;code&gt;NSView *&lt;/code&gt; 到底是可为空的引用还是不可为空的引用，所以 Swift 把此类型转换为一个隐式拆箱的可为空类型（implicitly unwrapped optional）—— &lt;code&gt;NSView!&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在此前的 Xcode 版本中，Apple 公司对一些框架做了特殊处理，以让它们在 Swift 被转换为适当的可为空类型。Xcode 6.3 引入了一个新的 Objective-C 特性：可为空性注释（nullability annotation），是的程序也能对自己的代码做出同样的处理。&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;核心关键字: &lt;code&gt;__nullable&lt;/code&gt;，&lt;code&gt;__nonnull&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;这项新特性的核心就是两个关键字：&lt;code&gt;__nullable&lt;/code&gt;，&lt;code&gt;__nonnull&lt;/code&gt;。正如你所想的那样，所有 &lt;code&gt;__nullable&lt;/code&gt; 指针可以为 &lt;code&gt;NULL&lt;/code&gt; 或者 &lt;code&gt;nil&lt;/code&gt;，而所有 &lt;code&gt;__nonnull&lt;/code&gt; 指针不行。如果你违反了此规则，编译器将会发出警告。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@interface AAPLList : NSObject &amp;lt;NSCoding, NSCopying&amp;gt;
// ...
- (AAPLListItem * __nullable)itemWithName:(NSString * __nonnull)name;
@property (copy, readonly) NSArray * __nonnull allItems;
// ...
@end

// --------------

[self.list itemWithName:nil]; // warning!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在您的 Objective-C 代码中，您几乎可以在任何可以用到 &lt;code&gt;const&lt;/code&gt; 关键字的地方使用 &lt;code&gt;__nullable&lt;/code&gt;，&lt;code&gt;__nonnull&lt;/code&gt;，当然必须是修饰指针类型。Swift 还未常用的场景提供了更加漂亮的注释方式：对于那些简单的对象类型或者块类型的类成员声明，您可以使用 &lt;code&gt;__nullable&lt;/code&gt;，&lt;code&gt;__nonnull&lt;/code&gt; 非下划线版本来就注释他们。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;- (nullable AAPLListItem *)itemWithName:(nonnull NSString *)name;
- (NSInteger)indexOfItem:(nonnull AAPLListItem *)item;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于属性，您也可以使用非下划线的版本，这次不是放在属性名前面，而是把他们挪到属性列表中（括号里面）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@property (copy, nullable) NSString *name;
@property (copy, readonly, nonnull) NSArray *allItems;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;非下划线的版本看起来更加舒服，但是您任然需要把他们加到所有需要的头文件中。您可以使用监控区域（audited region）来简化这个过程，并让头文件变得更加干净。&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;监控区域（andited region)&lt;/h1&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;兼容性&lt;/h1&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;回到 Swift&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - Media Frameworks</title>
      <link>http://localhost:1313/note/ios_notes_media_frameworks/</link>
      <pubDate>Wed, 29 Apr 2015 23:43:56 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_media_frameworks/</guid>
      <description>

&lt;h1 id=&#34;toc_0&#34;&gt;iOS Media Frameworks Stack&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/media_stack.svg&#34; alt=&#34;iOS media frameworks Stack&#34; /&gt;
&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;The Trunk Relation Graph&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/media_trunk_graph.svg&#34; alt=&#34;iOS media framework trunk relation graph&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift 官博文章翻译 - 通过减少动态调度来拉升程序性能</title>
      <link>http://localhost:1313/post/translation_swift_dynamic_dispath/</link>
      <pubDate>Wed, 29 Apr 2015 10:03:56 CST</pubDate>
      
      <guid>http://localhost:1313/post/translation_swift_dynamic_dispath/</guid>
      <description>

&lt;p&gt;原文链接：&lt;a href=&#34;https://developer.apple.com/swift/blog/?id=27&#34;&gt;Increasing Performance by Reducing Dynamic Dispatch &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译者：Mudox&lt;/p&gt;

&lt;p&gt;和其他很多语言一样，Swift 运行程序员改写从父类集成来的方法和属性。这意味着程序得在运行时也只用在运行时才能判断所引用的具体的方法或属性，并间接的调用或访问他们。这一技术名为“动态分配 dynamic dispatch”，通过为每次间接调用或访问增加常亮时间的开销来换取语言表达能力的提升。对于性能苛刻的代码，这类开销是不可取的。本文将展示三种通过消除此类动态性来拉升程序性能的方法：&lt;code&gt;final&lt;/code&gt;，&lt;code&gt;private&lt;/code&gt; 以及整模块优化策略。&lt;/p&gt;

&lt;p&gt;请看如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ParticleModel {
  var point = ( 0.0, 0.0 )
  var velocity = 100.0

  func updatePoint(newPoint: (Double, Double), newVelocity: Double) {
    point = newPoint
    velocity = newVelocity
  }

  func update(newP: (Double, Double), newV: Double) {
    updatePoint(newP, newVelocity: newV)
  }
}

var p = ParticleModel()
for i in stride(from: 0.0, through: 360, by: 1.0) {
  p.update((i * sin(i), i), newV:i*1000)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译器将会生成如下动态分派代码：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;调用 &lt;code&gt;update&lt;/code&gt; 于 &lt;code&gt;p&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;调用  &lt;code&gt;updatePoint&lt;/code&gt; 于 &lt;code&gt;p&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;访问 &lt;code&gt;p&lt;/code&gt; 的 &lt;code&gt;point&lt;/code&gt; 元祖属性。&lt;/li&gt;
&lt;li&gt;访问 &lt;code&gt;p&lt;/code&gt; 的 &lt;code&gt;velocity&lt;/code&gt; 属性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这也许并不是你想要的。动态调度在这里之所以必要，是因为 &lt;code&gt;ParticleModel&lt;/code&gt; 的子类可能重写其属性。&lt;/p&gt;

&lt;p&gt;在 Swift 中，动态调度通过从函数表中搜索正确的函数并间接调用他们来实现。这显然比直接调用来的慢。此外，间接调用还会阻碍很多编译器对代码的优化，这又进一步增加了程序运行的开销。在性能关键的代码中，Swift 提供了一些技术来关闭某些不必要的动态调度以拉升程序性能。&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;当你确定某个声明不会被覆盖时，使用 &lt;code&gt;final&lt;/code&gt; 关键字&lt;/h2&gt;

&lt;p&gt;关键字 &lt;code&gt;final&lt;/code&gt; 可以修饰类，方法或者属性的声明，它指示编译器这些声明不会被后续代码覆盖。这样编译器就能放心的在这些对象上关闭动态调度特性（不生成动态调度的代码）。比如下面的类属性 &lt;code&gt;point&lt;/code&gt;，&lt;code&gt;velocity&lt;/code&gt; 和函数 &lt;code&gt;updatePoint()&lt;/code&gt; 将被直接访问和调用。而方法 &lt;code&gt;update()&lt;/code&gt; 仍然需要通过动态调度来间接的被调用，它也因此能被子类们覆盖。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ParticleModel {
  final var point = ( x: 0.0, y: 0.0 )
  final var velocity = 100.0

  final func updatePoint(newPoint: (Double, Double), newVelocity: Double) {
    point = newPoint
    velocity = newVelocity
  }

  func update(newP: (Double, Double), newV: Double) {
    updatePoint(newP, newVelocity: newV)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is possible to mark an entire class as final by attaching the attribute to the class itself. This forbids subclassing the class, implying that all functions and properties of the class are final as well.&lt;/p&gt;

&lt;p&gt;您可以用 &lt;code&gt;final&lt;/code&gt; 修饰整个类的声明，这样做将直接禁止对该类的子类化，因此对其所有属性和方法的访问将都是直接的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;final class ParticleModel {
  var point = ( x: 0.0, y: 0.0 )
  var velocity = 100.0
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;为 &lt;code&gt;private&lt;/code&gt; 声明自动推导 &lt;code&gt;final&lt;/code&gt; 语义&lt;/h2&gt;

&lt;p&gt;被 &lt;code&gt;private&lt;/code&gt; 修饰的声明其可见性会限制在声明它的文件里。如果在该文件里，没有发现对该声明的覆盖，编译器就不会为该声明生成动态调度代码，而是直接的访问他们。&lt;/p&gt;

&lt;p&gt;假设在该文件中，没有对类 &lt;code&gt;ParticleModel&lt;/code&gt; 的覆盖，那么编译器就会关闭对其所有 &lt;code&gt;private&lt;/code&gt; 成员的动态调度，取而代之以更加快速的直接访问。
Assuming there is no class overriding ParticleModel in the current file, the compiler can replace all dynamically dispatched calls to private declarations with direct calls.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class ParticleModel {
  private var point = ( x: 0.0, y: 0.0 )
  private var velocity = 100.0

  private func updatePoint(newPoint: (Double, Double), newVelocity: Double) {
    point = newPoint
    velocity = newVelocity
  }

  func update(newP: (Double, Double), newV: Double) {
    updatePoint(newP, newVelocity: newV)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码中，&lt;code&gt;point&lt;/code&gt;，&lt;code&gt;velocity&lt;/code&gt; 和 &lt;code&gt;updatePoint()&lt;/code&gt; 将被直接访问和调用。由于 &lt;code&gt;update()&lt;/code&gt; 没有被 &lt;code&gt;private&lt;/code&gt; 修饰，它仍然需要被动态调度。&lt;/p&gt;

&lt;p&gt;和 &lt;code&gt;final&lt;/code&gt; 一样，&lt;code&gt;private&lt;/code&gt; 也可以被用来直接修饰整个类声明，这相当于在该类的所有成员声明面前加了 &lt;code&gt;private&lt;/code&gt; 关键字。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;private class ParticleModel {
  var point = ( x: 0.0, y: 0.0 )
  var velocity = 100.0
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;通过模块级的优化来对 &lt;code&gt;internal&lt;/code&gt; 声明推导出 &lt;code&gt;final&lt;/code&gt; 语义&lt;/h1&gt;

&lt;p&gt;在 Swift 中，所有声明的可见性默认为 &lt;code&gt;internal&lt;/code&gt;，也就是说他们只能在定义他们的模块内可见。编译器通常会单独的编译模块内的每个文件，因此它在变异某一个源文件时，无法判断在同意模块内的其他源文件里是否对该源文件内定义的 &lt;code&gt;internal&lt;/code&gt; 声明的覆盖。但是如果我们启用了编译器的 &lt;code&gt;Whole Module Optimization&lt;/code&gt; 模块级优选项，所以的文件将在一次编译过程中全部被编译。这样编译器就能在整个模块范围类分析是否某个 &lt;code&gt;internal&lt;/code&gt; 声明被覆盖了，从而推导出 &lt;code&gt;final&lt;/code&gt; 语义以关闭动态调度特性。&lt;/p&gt;

&lt;p&gt;让我们回到最开始的代码，这回我们额外添加一些 &lt;code&gt;public&lt;/code&gt; 关键到 &lt;code&gt;ParticleModel&lt;/code&gt; 的声明中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public class ParticleModel {
  var point = ( x: 0.0, y: 0.0 )
  var velocity = 100.0

  func updatePoint(newPoint: (Double, Double), newVelocity: Double) {
    point = newPoint
    velocity = newVelocity
  }

  public func update(newP: (Double, Double), newV: Double) {
    updatePoint(newP, newVelocity: newV)
  }
}

var p = ParticleModel()
for i in stride(from: 0.0, through: times, by: 1.0) {
  p.update((i * sin(i), i), newV:i*1000)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当开启了模块级优化选项的编译器处理以上代码时，它能够推导出 &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;velocity&lt;/code&gt; 和 &lt;code&gt;updatePoint()&lt;/code&gt; 方法可以关闭动态调度特性。与此相反，由于 &lt;code&gt;update()&lt;/code&gt; 被 &lt;code&gt;public&lt;/code&gt; 修饰，其可见性延伸到了模块之外，所以编译器无法断定它具有 &lt;code&gt;final&lt;/code&gt; 语义。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift 官博文章翻译 - 内存安全：确保值在使用前先初始化</title>
      <link>http://localhost:1313/post/translation_swift_memory_safety/</link>
      <pubDate>Tue, 28 Apr 2015 23:03:56 CST</pubDate>
      
      <guid>http://localhost:1313/post/translation_swift_memory_safety/</guid>
      <description>

&lt;p&gt;原文链接：&lt;a href=&#34;https://developer.apple.com/swift/blog/?id=28&#34;&gt;Memory Safety: Ensuring Values are Initialized Before Use&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译者：Mudox&lt;/p&gt;

&lt;p&gt;我们设计 Swift 这门语言时的一个重要的发力方向就是改进编程模型的内存安全性。内存安全有很多方面，本文将由浅入深，先从一个简单的问题开始：如果确保值在使用前被初始化。&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Swift 的方式&lt;/h1&gt;

&lt;p&gt;如果每当一个变量第一次被访问时，该变量都有一个有效的初始值，那么该变量就被认为是“安全”的。不同的语言采用了不同的方式来提供这种安全性。比如 C 语言，它将责任完全交给程序员——这种方法强大，但是也很有难度。C++ 和 Objective-C 通过施加一些强制性的模式来改善此类情况，还有一些语言则（比较极端的）要求变量在定义时就必须初始化。&lt;/p&gt;

&lt;p&gt;Swift 采用的主要技术是通过其先进的编译器来对代码的数据流进行分析。由编译器在编译时确保变量在使用前正确初始化，这是是一种名为 &lt;a href=&#34;http://en.wikipedia.org/wiki/Definite_assignment_analysis&#34;&gt;明确初始化——Definitive Initialization&lt;/a&gt; 的策略。还有很多语言比如 Java，C# 都采用了类似的策略，而 Swift 则是的该策略的一个扩展版本应用于更大范围的变量上面。&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;本地变量的明确初始化&lt;/h1&gt;

&lt;p&gt;在 Swift 中有很多场景都用到了该策略，其中最简单的场景就是用于本地变量。相较于“隐式的默认值初始化 implicit default initialization”，明确初始化初始化提供了更大的灵活性，因为它运行你写出如下的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var myInstance : MyClass  // Uninitialized non-nullable class reference

if x &amp;gt; 42 {
  myInstance = MyClass(intValue: 13)
} else {
  myInstance = MyClass(floatValue: 92.3)
}

// Okay because myInstance is initialized on all paths
myInstance.printIt()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里编译器能分析出 &lt;code&gt;if&lt;/code&gt; 语言的两个分支里都对变量 &lt;code&gt;myInstance&lt;/code&gt; 做了初始化，因此它确信后面的 &lt;code&gt;printIt()&lt;/code&gt; 方法不会被调用于未初始化的内存上面。&lt;/p&gt;

&lt;p&gt;明确初始化策非常强大，但是它只有在代码可靠并可预测的情况下才能发挥作用。当你的代码的控制流逻辑比较复杂时，它就可能出意外。比如如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var myInstance : MyClass

if x &amp;gt; 10 {
  myInstance = MyClass(intValue: 13)
}
// ...
if x &amp;gt; 42 {
  myInstance.printIt()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码运行时，编译器会发出警告：“变量 &lt;code&gt;myInstance&lt;/code&gt; 在使用前未初始化”。这是因为编译器并不能分析出上下两个 if 语句的条件之间的内在逻辑关系。尽管我们能让编译器照顾到此类个别特殊情况，但是它还是不可能覆盖所有的特殊情况（这其实就是所谓的“&lt;a href=&#34;http://en.wikipedia.org/wiki/Halting_problem&#34;&gt;停机问题 halting problem&lt;/a&gt;”），因此我们决定保持编译规则简单可预测。&lt;/p&gt;

&lt;p&gt;Swift 使初始化一个变量变得极其简单。事实上用 Swift 在声明时给出初始化值 &lt;code&gt;var x = 0&lt;/code&gt; 比声明一个未初始化的变量 &lt;code&gt;var x: Int&lt;/code&gt; 所得到的代码更简短。Swift 提倡在任何可能的时候给声明的变量一个明确的初始化值。还有更加强大的方法就是通过调用 &lt;code&gt;init()&lt;/code&gt; 方法来初始化一个变量。想要了解更加详细的信息，请参阅 Swfit Programming Language 的“&lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html&#34;&gt;初始化 Initialization&lt;/a&gt;” 一章。&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;其他的方式&lt;/h1&gt;

&lt;p&gt;除了明确初始化之外，Swift 在特定情况下也会采用一些其他的策略。您很可能已经在其他语言中碰到过这些策略，因此我们将在本文中简短的介绍下他们。他们都用各自不足之处，所以 Swift 并没有将他们当做主要策略来使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;将安全性交给程序员&lt;/strong&gt;：鉴于 C 的普及程度，我们有必要了解下简单的将安全性责任交给程序员这种做法的利与弊。在 C 中使用未经初始化的值会导致&lt;a href=&#34;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html&#34;&gt;不确定的行为 undefined behavior&lt;/a&gt;，经常表现为程序的运行时异常。C 语言依赖程序永远都不要犯错误。我们设计 Swift 语言的初衷之一就是让它从本质上就是安全的，所以这一策略果断被我们排除于绝大部分情况之外。但是，Swift 还是提供了诸如 &lt;code&gt;UnsafePointer&lt;/code&gt; 这样的 API，以允许你再绝对必要的情况下启用这种策略。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;隐式的默认值初始化&lt;/strong&gt;：可以让编译器隐式的初始化一个值，以确保其安全性。比如，在 Objective-C 中，给实例的成员变量设置一个初始的“零值”，或者像 C++ 那样给类提供默认的初始化器。我们曾深入探索过这一方法，但做种决定不广泛使用它。因为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;它对与那些没有合理初始化值的类型不起作用，比如 protocol 对象并没有 &lt;code&gt;init()&lt;/code&gt; 方法可以调用，已经在 Swift 非常普遍的不可为空的类引用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;就算是对于基本类型，比如对于一个 integer 变量，0 常常在上下文中是一个不合理的值。这也是为什么在 Swift 中给变量赋初始化值如此容易的原因之一。此外，这让代码对于后续的维护者更加的清晰明了。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：对于 &lt;code&gt;Optional&lt;/code&gt; 和 &lt;code&gt;ImplicitlyUnwrappedOptional&lt;/code&gt; 这类可以为空的值，把他们默认初始化为空 &lt;code&gt;nil&lt;/code&gt; 是理所当然的。因此在 Swift 中所有飞空值都会被自动初始化为空值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;强制在定义时初始化&lt;/strong&gt;：强制要求程序在定义变量是给与其初始值，意味着 &lt;code&gt;var x: Int&lt;/code&gt; 将是非法的，因为它没有提供初始值给编译器。尽管该策略通用于函数式编程语言中, 但是我们认为这一要求国语严格而没有必要，也妨碍了程序员对自然模式的表达。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - AMAP API DEPICTED</title>
      <link>http://localhost:1313/note/ios_notes_amap/</link>
      <pubDate>Tue, 28 Apr 2015 17:43:56 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_amap/</guid>
      <description>

&lt;p&gt;AMap (高德地图) APIs depicted in several graphs I draw.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;AMap Searching API&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/amap_searching_graph.svg&#34; alt=&#34;AMap Searching API Graph&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - LOCATION BASED SERVIES</title>
      <link>http://localhost:1313/note/ios_notes_lbs/</link>
      <pubDate>Fri, 17 Apr 2015 14:43:56 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_lbs/</guid>
      <description>

&lt;p&gt;Quick steps to use iOS&amp;rsquo;s LBS technology.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Core Location&lt;/h1&gt;

&lt;p&gt;iOS devices integrates various hardware components, such as:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;GPS (Global Positioning System) for positioning&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hardware compass for heading monitoring.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;WiFi for positioning.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Cellular network for cell-tower triangulation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Blue tooth for iBeacon ranging.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;some data sensors for improve positioning accuracy under some circumstances.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;to provides users with following LBS abilities as much as possible:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Location Updates&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Standard location updates&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Significant location updates&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Heading monitoring&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Region monitoring&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;iBeacon ranging&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Visit events&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The &lt;code&gt;CLLocationManager&lt;/code&gt; acts just like an &lt;code&gt;NSNotificationCenter&lt;/code&gt; (but it is not
a singleton) between the LBS hardwares and your App, you use it to request the
authorization for LBS functionalities you are planning to use afterwords, and
adjusts the relevant parameters of them before starting their notification
updating loops.&lt;/p&gt;

&lt;p&gt;After you call one of its&amp;rsquo; &lt;code&gt;start***&lt;/code&gt; or &lt;code&gt;request***&lt;/code&gt; methods to emit requests
for one of the 5 LBS abilities mentioned above, the &lt;code&gt;CLLocationManager&lt;/code&gt;
activate relevant hardware components, when the data is available it notifies
you asynchronously by calling one of the its&amp;rsquo; delegate&amp;rsquo;s methods.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/core_location_map.svg&#34; alt=&#34;Core Location Map&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Work flow of using LBS abilities.&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Project setup&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Enable &lt;em&gt;Background Location Updates Background Mode&lt;/em&gt; capability.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add &lt;em&gt;NSLocationAlwaysUsageDescriptions&lt;/em&gt; or
&lt;em&gt;NSLocationWhenInUseUsageDescription&lt;/em&gt; key to info.plist.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Configuring &lt;code&gt;CLLocationManager&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Creating a &lt;code&gt;CllocationManager&lt;/code&gt; instance and hold a strong reference to it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Specify location manager&amp;rsquo;s delegate, usually be a view controller.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check &amp;amp; request authorization status.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Configures the relevant properties for the LBS functionality you are about
to use.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Before starting each LBS updating functions, there are also corresponding
APIs you can invoke to check the services availability.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Call &lt;code&gt;start**&lt;/code&gt; methods to start the various LBS notification loops.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// declare as some long-standing reference outside of function body.
let locationManager = CLLocationManager()
--------------------
// within functions ( be it in viewDidLoad() )
// designate delegate
locationManager.delegate = self
// request for authorization
locationManager.requestAlwaysAuthorization()
// configure updating related settings
locationManager.activityType = .AutomotiveNavigation
locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation
locationManager.distanceFilter = 10
// finally check device &amp;amp; service availability before starting notification loop.
if CLLocationManager.locationServicesEnabled() {
  locationManager.startUpdatingLocation()
} else {
  let alert = UIAlertController(
    title: &amp;quot;Service Not Available&amp;quot;,
    message: &amp;quot;The location is not available or has been shut down.&amp;quot;,
    preferredStyle: .Alert)
  presentViewController(alert, animated: true, completion: nil)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Implement &lt;code&gt;CLLocationManagerDelegate&lt;/code&gt; methods in you designated delegate
object to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;handle received location data updates.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;handle LBS failures.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;handle authorization status changes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;hellip;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;MapKit&lt;/h1&gt;

&lt;p&gt;In general, MapKit:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;shows map in one of three map types:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Standard&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Satellite&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hybrid&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;along with many built-in elements:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;compass&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;POIs (points of interest)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;and provides developer with two kinds of customizable presentation
facilities:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;annotations&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;overlays&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As of managing annotations, MapKit adopts the same design pattern as that is
heavily used by &lt;code&gt;UITableView&lt;/code&gt; &amp;ndash; decoupling data model from presentation tools
through &lt;strong&gt;reuse pool&lt;/strong&gt;. Hence, there comes separate class hierarchies for
storing annotation (overlay) data, and presenting them respectively.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;data object&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;all objects that conforms to &lt;code&gt;MKAnnotation&lt;/code&gt; protocol, are responsible for
storing data for annotations, such as location, textual info, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;all objects that conforms to &lt;code&gt;MKOverlay&lt;/code&gt; protocol, are responsible for
storing data for overlays, such as location, etc.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;presentation tools&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;instances that inherit from &lt;code&gt;MKAnnotationView&lt;/code&gt; can be &lt;strong&gt;reused&lt;/strong&gt; to display a data objects.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;instances that inherit from &lt;code&gt;MKOverlayRenderer&lt;/code&gt; can be used to display a overlay objects.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/map_kit_map.svg&#34; alt=&#34;MapKit map&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Customize annotation view&lt;/h2&gt;

&lt;p&gt;A annotation view usually consist of 2 parts:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The view view.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Set its&amp;rsquo; &lt;code&gt;image&lt;/code&gt; property to change its&amp;rsquo; appearance.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The callout view, which is popped up when the pin view is selected.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The built-in callout view is not exposed for customization, so we should disable the &lt;code&gt;canShowCallout&lt;/code&gt; property&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SWIFT NOTES - CLOSURE</title>
      <link>http://localhost:1313/note/swift_notes_closure/</link>
      <pubDate>Tue, 14 Apr 2015 08:43:56 CST</pubDate>
      
      <guid>http://localhost:1313/note/swift_notes_closure/</guid>
      <description>

&lt;p&gt;Thanks to the host of technologies provided by the Swift
compiler, the closure comes with a bunch of syntactic
sugars that could sweet you to diabetes.&lt;/p&gt;

&lt;p&gt;The full syntax of a closure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;{
  (parameters) -&amp;gt; retrunType in
  ... statements ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is an example that uses the array&amp;rsquo;s method &lt;code&gt;sorted&lt;/code&gt; to sort an array of
word.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var words = [ &amp;quot;Dolor&amp;quot;, &amp;quot;eum&amp;quot;, &amp;quot;id&amp;quot;, &amp;quot;suscipit&amp;quot;, &amp;quot;necessitatibus&amp;quot;, &amp;quot;quod&amp;quot;, &amp;quot;hic&amp;quot;, &amp;quot;dignissimos&amp;quot; ]

let sortedWords = words.sorted({
  (lhs: String, rhs: String) -&amp;gt; Bool in
  return lhs &amp;lt; rhs
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the sugars introduced in, we will cut the lines above into an incredibly one
line of code.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Sugar #0 &amp;ndash; trailing closure&lt;/h1&gt;

&lt;p&gt;Often, closure parameter is placed last in parameter list. Swift thus provides
&lt;strong&gt;trailing closure&lt;/strong&gt;, which means your can write the inline closure just
outside the parameter list, following the closing &lt;code&gt;)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Furthermore, if the closure is the only parameter, then the parenthesis can be
omitted.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// trailing closure
let sortedWords = words.sorted/*()*/ {
  (lhs: String, rhs: String) -&amp;gt; Bool in
  return lhs &amp;lt; rhs
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Sugar #1 &amp;ndash; return type inference&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;return type&lt;/strong&gt; can be inferred by swift compiler.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// omit return type
let sortedWords = words.sorted {
  (lhs: String, rhs: String) /*-&amp;gt; Bool*/ in
  return lhs &amp;lt; rhs
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Sugar #2 &amp;ndash; parameter type inference&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;parameter types&lt;/strong&gt; can be inferred by swift compiler as well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// omit parameter types
let sortedWords = words.sorted {
  (lhs/*: String*/, rhs/*: String*/) /*-&amp;gt; Bool*/ in
  return lhs &amp;lt; rhs
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_3&#34;&gt;Sugar #3 &amp;ndash; parenthesis-less&lt;/h1&gt;

&lt;p&gt;Since no type annotation is needed, the &lt;strong&gt;parenthesis&lt;/strong&gt; can be omitted.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// omit parenthesis
let sortedWords = words.sorted {
  /*(*/lhs/*: String*/, rhs/*: String)*/ /*-&amp;gt; Bool*/ in
  return lhs &amp;lt; rhs
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;Sugar #4 &amp;ndash; return statement inference&lt;/h1&gt;

&lt;p&gt;If the closure has one statement, then the &lt;strong&gt;return&lt;/strong&gt; statement can also be
inferred.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// omit &#39;return&#39;
let sortedWords = words.sorted {
  /*(*/lhs/*: String*/, rhs/*: String)*/ /*-&amp;gt; Bool*/ in
  /*return*/ lhs &amp;lt; rhs
}

//then we got:
let sortedWords = words.sorted { lhs, rhs in lhs &amp;lt; rhs }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_5&#34;&gt;Sugar #5 &amp;ndash; shorthand parameter name&lt;/h1&gt;

&lt;p&gt;Swift provides &lt;strong&gt;shorthand parameter names&lt;/strong&gt;: $0 for the 1st parameter, $1 for
the 2nd parameter, and so on. And as an side effect, the whole &lt;code&gt;(parameters) -&amp;gt;
returType in&lt;/code&gt; statement can be completely omitted&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// use shorthand parameters, omit the whole &#39;in&#39; statement
let sortedWords = words.sorted {
  /*(lhs: String, rhs: String) -&amp;gt; Bool in*/
  /*return*/ $0 &amp;lt; $1
}

// then we got:
let sortedWords = words.sorted { $0 &amp;lt; $1 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;Sugar #6 &amp;ndash; operator as a closure&lt;/h1&gt;

&lt;p&gt;In swift, &lt;strong&gt;operator&lt;/strong&gt; is a function, which in turn is a &lt;strong&gt;special closure&lt;/strong&gt;, so&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// comes operator!
let sortedWords = words.sorted(&amp;lt;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>UNICODE CONCEPTS DEFINED</title>
      <link>http://localhost:1313/note/unicode_concepts_defined/</link>
      <pubDate>Mon, 13 Apr 2015 18:10:59 CST</pubDate>
      
      <guid>http://localhost:1313/note/unicode_concepts_defined/</guid>
      <description>&lt;p&gt;Collect several Unicode concepts encountered when I learn Swift&amp;rsquo;s String type.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;UCS&lt;/p&gt;

&lt;p&gt;Universal Coded Character Set (通用字符集)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The Universal Coded Character Set (UCS), defined by the International
Standard ISO/IEC 10646, Information technology — Universal Coded
Character Set (UCS) (plus amendments to that standard), is a standard set
of characters upon which many character encodings are based. The UCS
contains nearly one hundred thousand abstract characters, each identified
by an unambiguous name and an integer number called its code point.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unicode&lt;/p&gt;

&lt;p&gt;统一码，万国码, 单一码&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Unicode is a computing industry standard for the consistent encoding,
representation, and handling of text expressed in most of the world&amp;rsquo;s
writing systems. Developed in conjunction with the Universal Character
Set standard and published as The Unicode Standard, the latest version of
Unicode contains a repertoire of more than 110,000 characters covering
100 scripts and multiple symbol sets.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As for its&amp;rsquo; code space layout:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Unicode comprises 1,114,112 code points in the range 0x0 to 0x10FFFF.
The Unicode code space is divided into 17 planes (the basic multilingual
plane, and 16 supplementary planes), each with 65,536 (= 216) code
points. Thus the total size of the Unicode code space is 17 × 65,536 =
1,114,112.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UTF&lt;/p&gt;

&lt;p&gt;UCS/Unicode Transformation Format (通用字符集转换格式, Unicode 转换格式)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UTF-8&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;UTF-8 (U from Universal Character Set + Transformation Format—8-bit[1])
is a character encoding capable of encoding all possible characters
(called code points) in Unicode. The encoding is variable-length and uses
8-bit code units. It was designed for backward compatibility with ASCII
and to avoid the complications of endianness and byte order marks in
UTF-16 and UTF-32.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;code point (code position)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In character encoding terminology, a code point or code position is any
of the numerical values that make up the code space.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unicode scalar&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Behind the scenes, Swift’s native String type is built from Unicode
scalar values. A Unicode scalar is a unique 21-bit number for a character
or modifier.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The distinction between Unicode scalar &amp;amp; Unicode code point could be
clarified as follows:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A Unicode scalar is any Unicode code point in the range U+0000 to U+D7FF
inclusive or U+E000 to U+10FFFF inclusive. Unicode scalars do not include
the Unicode surrogate pair code points, which are the code points in the
range U+D800 to U+DFFF inclusive.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It is a Swift language specific notion, or more actually, a Swift defined
internal type for storing string charactor&amp;rsquo;s Unicode points that Swift
choose to support. Behind the scene, it&amp;rsquo;s a 21bit long numeric type, but
not all number in the range can reponds to a valid Unicode point.&lt;/p&gt;

&lt;p&gt;So mathematically, the Unicode points universal set is a discrete subset of
integer set [0, 0x10FFFF]. The Swift Unicode scalar universal set is, in
turn, a discrete subset of Unicode code point universal set (with all
&lt;em&gt;surroagte pair&lt;/em&gt; code points stripped).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;code unit&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A code unit is a bit sequence used to encode each character of a
repertoire. Encodings associate their meaning with either a single code
unit value or a sequence of code units as one value.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;extended grapheme cluster&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Every instance of Swift’s Character type represents a single extended
grapheme cluster. An extended grapheme cluster is a sequence of one or
more Unicode scalars that (when combined) produce a single human-readable
character.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SWIFT NOTES - FUNCTIONS</title>
      <link>http://localhost:1313/note/swift_notes_functions/</link>
      <pubDate>Mon, 13 Apr 2015 16:26:59 CST</pubDate>
      
      <guid>http://localhost:1313/note/swift_notes_functions/</guid>
      <description>

&lt;p&gt;Excerpts from the &amp;ldquo;Functions&amp;rdquo; section of the official docuemnt &amp;ldquo;The Swift
Programming Language&amp;rdquo;&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Function Parameters&lt;/h1&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Parameter names&lt;/h2&gt;

&lt;p&gt;A parameter name can have a &lt;strong&gt;internal name&lt;/strong&gt; and an &lt;strong&gt;external name&lt;/strong&gt; declared
in the form of: &lt;code&gt;external_name internal_name: type&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func join(String string: leftString, toString rightString) -&amp;gt; String {
  return leftString + rightString
}

println(join(String: &amp;quot;Hello&amp;quot;, toString: &amp;quot; World!&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use &lt;code&gt;#&lt;/code&gt; to use the same name for both names: &lt;code&gt;#name: type&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func join(#aString: leftString, #toString) -&amp;gt; String {
  return aString + toString
}

println(join(aString: &amp;quot;Hello&amp;quot;, toString: &amp;quot; World!&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use &lt;code&gt;_&lt;/code&gt; to suppress external name: &lt;code&gt;_ internal_name: type&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func join(_ aString: leftString, _ toString) -&amp;gt; String {
  return aString + toString
}

println(join(&amp;quot;Hello&amp;quot;, &amp;quot; World!&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Parameters with default value&lt;/h2&gt;

&lt;p&gt;Default parameter values of the &lt;code&gt;[external_name /_/#]internal_name: type =
default_value&lt;/code&gt; should be placed at end of the parameter list.&lt;/p&gt;

&lt;p&gt;The compiler will synthesize a external name by reusing the internal name for
parameters with default value, if their external name is not explicitly
specified in the parameter list. (You can use &lt;code&gt;_&lt;/code&gt; to suppress this behavior,
which is not recommended.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func Foo(arg1: String, arg2: Int = 30, _ arg3: Bool, #arg4: Double) {
  ...
}

Foo(&amp;quot;text&amp;quot;, arg2: 1, true, arg4: 4.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Variadic parameters&lt;/h2&gt;

&lt;p&gt;Declare variadic parameter in form &lt;code&gt;name: type...&lt;/code&gt;, which, in the function
body, is of type &lt;code&gt;[type]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Only one variadic parameter is allowed in a parameter list, and it should be
placed after all other normal parameters or parameters with default value.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Variable parameters&lt;/h2&gt;

&lt;p&gt;Prefix parameter names with keyword &lt;code&gt;var&lt;/code&gt; to make them modifiable inside the
function body.&lt;/p&gt;

&lt;p&gt;It is just another small syntactic sugar brought by Swift, the change made in
the function body will not propagate outside the function body.&lt;/p&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;In-Out parameters&lt;/h2&gt;

&lt;p&gt;Prefix parameters names with keyword &lt;code&gt;inout&lt;/code&gt; (which implies &lt;code&gt;var&lt;/code&gt;) to make the
change to the parameter inside function body propagate outside.&lt;/p&gt;

&lt;p&gt;When specifying argument for &lt;code&gt;inout&lt;/code&gt; parameters, prepend &lt;code&gt;&amp;amp;&lt;/code&gt; to the argument
name to indicate that it could be modified during the function call.&lt;/p&gt;

&lt;p&gt;In-out parameters cannot have default values, and variadic parameters cannot be
marked as &lt;code&gt;inout&lt;/code&gt;. If you mark a parameter as &lt;code&gt;inout&lt;/code&gt;, it cannot also be marked
as var or let.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func swapTwoInts(inout a: Int, inout b: Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}

var a = 2
var b = 10
swapTwoInts(&amp;amp;a, &amp;amp;b)
println(&amp;quot;after swapping, a = \(a), b = \(b)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_6&#34;&gt;Function Return Values&lt;/h1&gt;

&lt;p&gt;Functions without a defined return type return a special value of type
&lt;strong&gt;Void&lt;/strong&gt;.  This is simply an empty tuple, in effect a tuple with zero elements,
which can be written as &lt;code&gt;()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can use a tuple type (or a optional tuple) as the return type for a
function to return multiple values as part of one compound return value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// wrap multiple return values in an optional tuple.
func minMax(array: [Int]) -&amp;gt; (min: Int, max: Int)? { ... }

if let minMax = minMax([1,2,3]) {
  // use name to fetch tuple element.
  println(&amp;quot;min: \(minMax.min)\tmax: \(minMax.max)&amp;quot;)

  // use index to fetch tuple elements.
  println(&amp;quot;min: \(minMax.0)\tmax: \(minMax.1)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;Function Types&lt;/h1&gt;

&lt;p&gt;In Swift, function is first class object, so feel free to use them as other
normal objects:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;passing them as argument into functions.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;return them from functions.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;declare theme as type alias for convenience.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;even nest their in another function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;hellip;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;typealias cmp = (Int, Int) -&amp;gt; Bool

func whichCmp(functionPassedIn: ()-&amp;gt; Bool) -&amp;gt; cmp {
  func Foo(lhs: Int, rhs: Int) -&amp;gt; Bool {
    return false
  }

  func Hoo(lhs: Int, rhs: Int) -&amp;gt; Bool {
    return true
  }

  return functionPassedIn() ? Foo : Hoo
}

func aFunc() -&amp;gt; Bool {
  return false
}

whichCmp(aFunc)(1334, 234)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>iOS NOTES - CASTING</title>
      <link>http://localhost:1313/note/ios_notes_casting/</link>
      <pubDate>Sun, 12 Apr 2015 14:43:56 CST</pubDate>
      
      <guid>http://localhost:1313/note/ios_notes_casting/</guid>
      <description>

&lt;p&gt;Collect all my gain from study &amp;amp; using Swift&amp;rsquo;s casting mechanism here.&lt;/p&gt;

&lt;p&gt;First defining a sample class hierarchy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class SuperClass {
  func say() {
    println(&amp;quot;super class&amp;quot;)
  }
}

class Subclass: SuperClass {
  override func say() {
    println(&amp;quot;subclass&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;3 Kinds of Castings&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Natural Casting&lt;/p&gt;

&lt;p&gt;Used in &lt;strong&gt;up-casting&lt;/strong&gt; (i.e. casting from a sub-class instance to a super
class instance)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var a = SubClass()
var b = a as SuperClass
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unconditional Casting (or forced casting)&lt;/p&gt;

&lt;p&gt;Used in &lt;strong&gt;down-casting&lt;/strong&gt; (i.e. the contrary of the above).&lt;/p&gt;

&lt;p&gt;When the casting failed, it would incur a panic.&lt;/p&gt;

&lt;p&gt;Use it when you are confident about the down-casting.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conditional Casting&lt;/p&gt;

&lt;p&gt;Used in &lt;strong&gt;down-casting&lt;/strong&gt;, but it always returns optionals whether succeed
or fail, that means when not
applicalbe, instead of emitting a panic, it returns nil.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Conclusion:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Natural casting is used in &lt;em&gt;always-succeed&lt;/em&gt; castings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conditional &amp;amp; Unconditional castings are used in &lt;em&gt;might-fail&lt;/em&gt; castings.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;2 Operator for Casting&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;is&lt;/code&gt; operator&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;code&gt;as&lt;/code&gt; operators - &lt;code&gt;as&lt;/code&gt;, &lt;code&gt;as?&lt;/code&gt;, &lt;code&gt;as!&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Special casting scenarios in practice&lt;/h1&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Protocol Casting&lt;/h2&gt;

&lt;p&gt;In Swift the relationship between a protocol and the classes adopting that
protocol is like the relationship between a super class and its&amp;rsquo; sub-classes.
Hence casting a protocol object, such as the &lt;code&gt;AnyObject&lt;/code&gt; to its&amp;rsquo; underlying
class is regarded as a down-casting.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit // import AppKit

let a: AnyObject = &amp;quot;String&amp;quot;
let b: a as! String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are 3 special types: &lt;code&gt;Any&lt;/code&gt;, &lt;code&gt;AnyObject&lt;/code&gt;, &lt;code&gt;AnyClass&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;By tracing the source code, you would find the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;/// The protocol to which all classes implicitly conform.
///
/// When used as a concrete type, all known `@objc` methods and
/// properties are available, as implicitly-unwrapped-optional methods
/// and properties respectively, on each instance of `AnyObject`.
@objc procotol AnyObject {}

/// The protocol to which all class types implicitly conform.
///
/// When used as a concrete type, all known `@objc` `class` methods and
/// properties are available, as implicitly-unwrapped-optional methods
/// and properties respectively, on each instance of `AnyClass`.
typealias AnyClass = AnyObject.Type

/// The protocol to which all types implicitly conform
typealias Any = protocol&amp;lt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There exists a prerequisite for the rules all above: the &lt;code&gt;Foundation&lt;/code&gt; framework
must be imported. (Usually, you import &lt;code&gt;UIKit&lt;/code&gt; or &lt;code&gt;AppKit&lt;/code&gt;, which implicitly
import &lt;code&gt;Foundation&lt;/code&gt; framework). Only then can swift compiler be able to
recognize the &lt;code&gt;@objc&lt;/code&gt; keyword, and have Objective-C type bridging ability.&lt;/p&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Optional AnyObject Collection Casting&lt;/h2&gt;

&lt;p&gt;For a optional of Collection of AnyObject that reference objects of the same
class (or super class) T, can be [un]conditionally casted to [T] (without
being wrapped in optional anymore)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import UIKit // import Appkit

// optional array of String.
let a: [AnyObject]? = [&amp;quot;Newyork&amp;quot;, &amp;quot;London&amp;quot;, &amp;quot;Peking&amp;quot;]
let b = a as! [String] // succeed.

// optional array of mixed object that have no common super class.
let a: [AnyObject]? = [&amp;quot;Newyork&amp;quot;, 1983, 3.14, false]
let b = a as! [String] // fail: not all element are of String.

// optinal array of mixed objects that derived from the same super class.
let a: [AnyObject]? = [Subclass(), SuperClass(), SuperClass(), Subclass()]
let b = a as! [Subclass] // succeed: not all element are of String.

// implicitly unwrapped optional dictionary with String typped keys and Int typed values.
let a: [NSObject: AnyObject]! = [&amp;quot;id1&amp;quot;: 32, &amp;quot;id2&amp;quot;: 66]
if let b = a as? [String: Int] {
  println(b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code list above, the String is a structure type in Swift (no a class
type), but it can also be referenced by a &lt;code&gt;AnyObject&lt;/code&gt; instance. The rules come
from the following excerpt from &amp;ldquo;Using Swift with Cocoa and Objective-C&amp;rdquo;
official document:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An object is AnyObject compatible if it is an instance of an Objective-C or
Swift class, or if the object can be bridged to one.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There exist several swift - Objective-C type bridging depicted as follows:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../../note/swift_objc_bridging.svg&#34; alt=&#34;Siwft - Objective-C Bridging&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Hence, back to the code listing above, the Swift type &lt;code&gt;String&lt;/code&gt; can be bridged
to NSString &lt;code&gt;Foundation&lt;/code&gt; class, then it is &lt;code&gt;AnyObject&lt;/code&gt; compatible.&lt;/p&gt;

&lt;p&gt;In practice, there exists quit a few occasions that you need to cast optional
collections to type specific Swift collections to utilize their underlying
methods or properties.&lt;/p&gt;

&lt;p&gt;For example, when you invoke the Objective-C APIs that return &lt;code&gt;NSArray&lt;/code&gt;,
&lt;code&gt;NSDictionary&lt;/code&gt;, &lt;code&gt;NSSet&lt;/code&gt;, you would get &lt;code&gt;[AnyOject]!&lt;/code&gt; &lt;code&gt;[NSObject: AnyOject]!&lt;/code&gt;,
&lt;code&gt;[NSObject]!&lt;/code&gt; respectively, you could cast [un]conditionally to a more concrete
Swift collection type before you access the individual elements within they.&lt;/p&gt;

&lt;p&gt;When you use &lt;code&gt;as!&lt;/code&gt; (the unconditional casting), you got an unwrapped collection
in one line of code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let asset: AVURLAsset = ...
for meta in asset.commonMetadata as! [AVMetadataItem] {
  switch meta.commonKey {
  case AVMetadataCommonKeyTitle:
    item.title = meta.stringValue
  case AVMetadataCommonKeyArtist:
    item.artist = meta.stringValue
  case AVMetadataCommonKeyAlbumName:
    item.albumName = meta.stringValue
  case AVMetadataCommonKeyArtwork:
    switch meta.value {
    case let data as NSData:
      item.artwork = UIImage(data: data)
    case let dict as [NSObject: AnyObject]:
      item.artwork = UIImage(data: dict[&amp;quot;data&amp;quot;] as! NSData)
    default:
      assert(false, &amp;quot;Invalid metadata value type&amp;quot;)
    }
  default:
    break
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ERROR COLLECTION - IOS</title>
      <link>http://localhost:1313/memo/error_collection_ios/</link>
      <pubDate>Sat, 07 Feb 2015 09:24:33 CST</pubDate>
      
      <guid>http://localhost:1313/memo/error_collection_ios/</guid>
      <description>&lt;p&gt;Errors that I collected day by day, when developing iOS apps.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Specifying an invalid frame size (i.e. 0 width or 0 height), can make
UIView&amp;rsquo;s such as UISlider unresponsive to user interaction.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Always wrap multiple statements following a &lt;code&gt;switch case:&lt;/code&gt; in a curly brace,
where we can even put a variable declaration in it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Should &lt;strong&gt;NOT&lt;/strong&gt; assgin one instance of &lt;code&gt;UIImage&lt;/code&gt; to multiple
&lt;code&gt;UITextField.leftView&lt;/code&gt; or &lt;code&gt;UITextField.rightView&lt;/code&gt; properties.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UIImageView, by defaults, is &lt;strong&gt;NOT&lt;/strong&gt; userInteractionEnabled, hence sub views
under them may not receive touch events.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When creating outlets for UILabel views, &lt;strong&gt;DO NOT&lt;/strong&gt; name the property
&amp;ldquo;title&amp;rdquo;, cause the super class of your view controller &lt;code&gt;UIViewController&lt;/code&gt;
itself has a property &amp;lsquo;title&amp;rsquo;, it will incur exception at runtime time.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Remember to clean dead connnection recorded by storyboards for controls &amp;amp;
views in interface builder window.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Dragging an element with &lt;Atl&gt; key pressed, will copy it&amp;rsquo;s attributes as well as
it&amp;rsquo;s connections and other info set in the interface builder and uitility
panes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When presenting a view controller from a content view controller embeded in a
&lt;strong&gt;navigation view controller&lt;/strong&gt;, it is the navigation view controller, rather
than the embeded content view controller, which is &lt;strong&gt;presenting&lt;/strong&gt; the view
controller.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When customizing table view cells, &lt;strong&gt;DOT NOT&lt;/strong&gt; use &lt;code&gt;UIButton&lt;/code&gt; to cover the cell for
triggering the segue, which would bring a function redundant and thus
complicates things.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;DO NOT&lt;/strong&gt; auto-layout a subview within a auto-layout&amp;rsquo;ed &lt;code&gt;UIScrollView&lt;/code&gt; when
you plan to perform zooming operation in it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;After getting a reused cell, make sure all its&amp;rsquo; states get reset to the current
value or the default value, otherwise the remained states set by last usage
would mess your up.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;setting &lt;code&gt;clipsToBounds&lt;/code&gt; to true will clips layer shadow off.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SETUP MY VIM ENVIRONMENT</title>
      <link>http://localhost:1313/memo/setup_my_vim_environment/</link>
      <pubDate>Sat, 08 Nov 2014 17:40:55 CST</pubDate>
      
      <guid>http://localhost:1313/memo/setup_my_vim_environment/</guid>
      <description>

&lt;p&gt;It is the Vim that bring we into the marvelous OSS world. Fiddling with it is
full of surprise and happy.&lt;/p&gt;

&lt;p&gt;Below records my steps of setting up my Vim environment after every system
re-installation.&lt;/p&gt;

&lt;h1 id=&#34;toc_0&#34;&gt;Installing Vim&lt;/h1&gt;

&lt;p&gt;my vim config have be tested on:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Windows XP and above.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mac OSX 10.9 and above using &lt;a href=&#34;https://github.com/b4winckler/macvim&#34;&gt;MacVim&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Arch Linux.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: currently I prefer to GUI version than terminal version, hence most
of my configurations are tailored to GUI environments.&lt;/p&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;Setup My Vim-Config Repo&lt;/h1&gt;

&lt;p&gt;First pull down my &lt;a href=&#34;https://github.com/Mudox/vim-config&#34;&gt;vim-config&lt;/a&gt; repo from github.&lt;/p&gt;

&lt;p&gt;Then create a directory named &lt;em&gt;neobundle&lt;/em&gt; under the pulled down repo, which
will holds almost all vim plugins that will be synced by &lt;a href=&#34;https://github.com/Shougo/neobundle.vim&#34;&gt;neobundle&lt;/a&gt;
later.&lt;/p&gt;

&lt;p&gt;Create the initial &lt;em&gt;cur_mode&lt;/em&gt; file under &lt;em&gt;.vim/chameleon/&lt;/em&gt;, which always stores
the chameleon mode of next vim session.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# On Widnows, Must Be Put In C:/Documents And Settings/&amp;lt;User Name&amp;gt;/Vimfiles
git clone https://github.com/Mudox/vim-config.git ~/.vim

cd .vim
mkdir neobundle

cd chameleon
echo &#39;all&#39; &amp;gt; cur_mode
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;Install Prerequisites Vim Plugins&lt;/h1&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;Install &lt;a href=&#34;https://github.com/Mudox/vim-chameleon&#34;&gt;vim-chameleon&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Mudox/vim-chameleon&#34;&gt;vim-chameleon&lt;/a&gt; is my own plugin for managing massive and ever
growing vim &amp;amp; vim plugin configurations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~/.vim/neobundle
# NOTE: The Renaming Is Important
git clone https://github.com/Mudox/vim-chameleon chameleon
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Install &lt;a href=&#34;https://github.com/Shougo/neobundle.vim&#34;&gt;neobundle&lt;/a&gt;.&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Shougo/neobundle.vim&#34;&gt;neobundle&lt;/a&gt; is a sophisticated vim plugin manager that I have been
using for a long time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~/.vim/neobundle
# NOTE: The Renaming Is Important
git clone https://github.com/Shougo/neobundle.vim neobundle
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_5&#34;&gt;Install &amp;amp; compile &lt;a href=&#34;https://github.com/Shougo/vimproc.vim&#34;&gt;vimproc&lt;/a&gt;.&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Shougo/vimproc.vim&#34;&gt;vimproc&lt;/a&gt; is another plugin written by &lt;a href=&#34;https://github.com/Shougo&#34;&gt;Shougo&lt;/a&gt; that is very
useful, and is required by &lt;a href=&#34;https://github.com/Shougo/neobundle.vim&#34;&gt;neobundle&lt;/a&gt;. The point is that you need to
compile it to get a dynamic library after pulling down its&amp;rsquo; repo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~/.vim/neobundle
# NOTE: The Renaming Is Important
git clone https://github.com/Shougo/vimproc.vim vimproc

cd vimproc
make # see vimproc/README.md for compilation commands for various platforms.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_6&#34;&gt;Run vim to see all other 140+ plugins get installed.&lt;/h2&gt;

&lt;p&gt;You can run vim in terminals or open gVim. Better run vim in terminal to watch
the plugins installing progress and spot any errors clearly.&lt;/p&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;Vim Environment For Specific Use Case&lt;/h1&gt;

&lt;h2 id=&#34;toc_8&#34;&gt;Web Developing&lt;/h2&gt;

&lt;p&gt;Node.js (and NPM which comes with it) is the essentials of everything below.&lt;/p&gt;

&lt;h3 id=&#34;toc_9&#34;&gt;HTML&lt;/h3&gt;

&lt;h3 id=&#34;toc_10&#34;&gt;JavaScript&lt;/h3&gt;

&lt;p&gt;I use:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/jshint/jshint&#34;&gt;jshint&lt;/a&gt; &amp;amp;
&lt;a href=&#34;https://github.com/eslint/eslint&#34;&gt;eshint&lt;/a&gt; &amp;amp;
&lt;a href=&#34;https://github.com/douglascrockford/JSLint.git&#34;&gt;jslint&lt;/a&gt; for &lt;a href=&#34;https://github.com/scrooloose/syntastic&#34;&gt;syntastic&lt;/a&gt;
checkers.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/beautify-web/js-beautify&#34;&gt;js-beautify&lt;/a&gt; to prettify
JavaScript code.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm install jshint -g
npm install jslint -g
npm install eslint -g
npm install js-beautify -g
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_11&#34;&gt;CSS&lt;/h3&gt;

&lt;p&gt;I use:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/CSSLint/csslint&#34;&gt;csslint&lt;/a&gt; for &lt;a href=&#34;https://github.com/scrooloose/syntastic&#34;&gt;syntastic&lt;/a&gt; checkers.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/csscomb/csscomb.js&#34;&gt;csscomb.js&lt;/a&gt; for CSS code prettifier.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;npm intall csslint -g
npm install csscomb -g
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_12&#34;&gt;Python Scripting&lt;/h2&gt;

&lt;h2 id=&#34;toc_13&#34;&gt;Lua Scripting&lt;/h2&gt;

&lt;h2 id=&#34;toc_14&#34;&gt;Go Scripting&lt;/h2&gt;

&lt;h2 id=&#34;toc_15&#34;&gt;C/C++ Coding&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>ERROR COLLECTION - BASH</title>
      <link>http://localhost:1313/memo/error_collection_bash/</link>
      <pubDate>Fri, 07 Nov 2014 09:24:33 CST</pubDate>
      
      <guid>http://localhost:1313/memo/error_collection_bash/</guid>
      <description>&lt;p&gt;Errors that I collected day by day, when writing the Bash scripting language.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Body of &lt;code&gt;select&lt;/code&gt; constructs need a &lt;code&gt;break;&lt;/code&gt; to quit the selection loop.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;select answer in #choices#; do
  #body#
  break; # &amp;lt;- go out of selection loop.
done
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Always &lt;code&gt;source&lt;/code&gt; before testing a updated command.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Whence quoted with &lt;code&gt;&amp;quot;&lt;/code&gt;, which is the most case, use the &lt;code&gt;@&lt;/code&gt; form (i.e.
&lt;code&gt;&amp;quot;${ARRAY[@]}&amp;quot;&lt;/code&gt;) to expand a array correctly. The &lt;code&gt;*&lt;/code&gt; form will make the
expanded string as a &lt;strong&gt;single word&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;code&gt;local path&lt;/code&gt; is the source of all evil. It will shaddow the global &lt;code&gt;path&lt;/code&gt;
where binary search paths is hold in zsh.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;No need to &lt;code&gt;&amp;quot;&lt;/code&gt; quote variable that expand to a number in &lt;code&gt;$(( ))&lt;/code&gt;, which need
a real number.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;index=$(( RANDOM % &amp;quot;${#array[@]}&amp;quot; )) # no need to double quote &#39;${array[@]}&#39; here
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ERROR COLLECTION - BASH</title>
      <link>http://localhost:1313/memo/error_collection_sh/</link>
      <pubDate>Fri, 07 Nov 2014 09:24:33 CST</pubDate>
      
      <guid>http://localhost:1313/memo/error_collection_sh/</guid>
      <description>&lt;p&gt;Errors that I collected day by day, when writing the Bash scripting language.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Body of &lt;code&gt;select&lt;/code&gt; constructs need a &lt;code&gt;break;&lt;/code&gt; to quit the selection loop.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;select answer in #choices#; do
  #body#
  break; # &amp;lt;- go out of selection loop.
done
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Always &lt;code&gt;source&lt;/code&gt; before testing a updated command.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Whence quoted with &lt;code&gt;&amp;quot;&lt;/code&gt;, which is the most case, use the &lt;code&gt;@&lt;/code&gt; form (i.e.
&lt;code&gt;&amp;quot;${ARRAY[@]}&amp;quot;&lt;/code&gt;) to expand a array correctly. The &lt;code&gt;*&lt;/code&gt; form will make the
expanded string as a &lt;strong&gt;single word&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>SETUP MY ZSH ENVIRONMENT</title>
      <link>http://localhost:1313/memo/setup_my_zsh_environment/</link>
      <pubDate>Wed, 05 Nov 2014 09:34:11 CST</pubDate>
      
      <guid>http://localhost:1313/memo/setup_my_zsh_environment/</guid>
      <description>

&lt;p&gt;Steps of setting up zsh environment on my systems (Arch Linux, MacOS,
Windows/Cygwin).&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;the &lt;code&gt;z&lt;/code&gt; command&lt;/h2&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;the &lt;code&gt;fzf&lt;/code&gt; command&lt;/h2&gt;
</description>
    </item>
    
  </channel>
</rss>